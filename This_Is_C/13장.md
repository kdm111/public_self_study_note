# 포인터와 배열

### 포인터와 배열의 관계

배열의 이름은 상수 형태의 포인터이다.

int형 배열요소간 주소 값의 차는 4바이트이다. 

포인터 변수와 배열의 이름을 비교해보자.

포인터 변수 : 이름이 존재한다. 메모리의 주소값을 나타낸다. 주소 값의 변경이 가능하다.

배열의 이름 : 이름이 존재한다. 메모리의 주소값을 나타내고, 주소 값이 불가능하다.

배열의 이름은 상수 형태의 포인터이다. 배열의 이름도 포인터라면 포인터 변수를 대상으로 하는 \*연산도 가능하다.

*1차원 배열이름의 포인터 형과 배열 이름을 대상으로 하는 \*연산*

```c
int arr1[5];
```

배열의 이름 arr1이 가리키는 것은 배열의 첫 번째 요소이다. arr1은 int형 포인터라는 결론이 나오며, 이것이 실제로 arr1의 포인터 형이 된다. 

```c
double arr2[8];
```

arr2는 double형 포인터는 double형 포인터 double \*이 된다.1차원 배열이름의 포인터 형은 배열의 이름이 가리키는 대상을 기준으로 결정한다.

*포인터를 배열의 이름처럼 사용할 수 있다*

배열의 이름과 포인터 변수는 변수냐 상수냐의 차이점만 있을 뿐 둘 다 포인터 이긱 때문에 포인터 변수로 할 수 있는 연산은 배열의 이름으로 할 수 있고 배열의 이름으로 할 수 있는 연산은 포인터 변수로도 할 수 있다.

```c
int main(void)
{
    int arr[3] = {1,2,3};
    int *ptr = &arr[0];
    
    printf("%d %d",*ptr, *arr);
}
```



### 포인터 연산

*포인터를 대상으로 하는 증가 및 감소연산*

Int형 포인터를 대상으로 1을 증가시키면 4가 증가하고, double형 포인터를 대상으로 1을 증가시키면 8이 증가한다. 

```c
int main(void)
{
    int arr[3] = {1,2,3};
    int *ptr = arr;
    printf("%d %d %d", *ptr, *(ptr+1), *(ptr+2));
    
}
```

```c
*(++ptr)=20; // ptr에 저장된 값 자체를 변경
*(ptr+1)=20; // ptr에 저장된 값은 변경되지 않음
```

두 문장 모두 현재 ptr이 가리키는 위치에서 4바이트 떨어진 공간에 20을 저장하는 문장이다. 하지만 첫 번째 문장은 ptr에 저장된 값이 4증가한다. 하지만 두 번째 문장에서는 ptr의 값이 증가하지 않는다.

*중요한 결론 arr[i] == \*arr[i+1]*



### 상수 형태의 문자열을 가리키는 포인터

마지막에 널 문자가 삽입되는 문자열의 선언 방식에는 두 가지가 있다. 하나는 배열을 사용하는 방법이고 다른 하나는 char *포인터 변수를 사용하는 방법이다.

```c
char str1[] = "abcd";
char *str2 = "abcd";
```

이렇게 선언하면 str1은 그 자체로 문자열을 저장하는 배열이고 str2는 포인터 변수는 다른 위치를 가리킬 수 있다.



### 포인터 배열

*포인터 배열의 이해*

포인터 변수로 이루어진 그래서 주소 값의 저장이 가능한 배열을 가리켜 포인터 배열이라고 한다. 그리고 이러한 배열의 선언은 다음과 같다.

```c
int *arr1[20];
double *arr2[30];
```

포인터 배열의 선언 방식은 기본 자료형 배열과 동일하다.

```c
int main(void)
{
    int num1=10, num2=20, num3=30;
    int *arr[3] = {&num1, &num2, &num3};
    printf("%d %d %d", *arr[0], *arr[1], *arr[2]);
}
```

*문자열을 저장하는 포인터 배열*

문자열 배열은 다음과 같다.

```c
char *strArr[3];
```

char 형 포인터 배열은 문자열의 주소값을 저장할 수 있는 배열로 불리다보니 문자열 배열로 불릴 뿐이다.

```c
int main(void)
{
    char *strArr[3] = {"abc", "def", "ghi"};
    printf("%s", strArr[0]); // abc
    printf("%s", strArr[1]); // def
    printf("%s", strArr[2]); // ghi
}
```

큰 따옴표로 묶여서 표현되는 문자열은 그 형태에 관계없이 메모리 공간에 저장된 후 그 주소 값이 반환된다.

```c
char *strArr = {0x1100, 0x1230, 0x3213};
```


























































'''
LeetCode 253 : Meeting Rooms II
회의가 들어 있는 리스트가 있을 때 최소한 필요한 방의 개수

# sol1 172ms 48% 17.5MB 84%
O(nlogn) O(n)
방을 만들어 놓고 방이 비어있는 지 여부를 확인하고 싶을 때마다 민힙을 사용한다.
현재 사용 중인 다른 모든 방 중에서 가장 먼저 비워지는 방이 될 것이기 대문이다.
비어있지 않으면 새 방을 할당하여 놓는다.

# sol2 226ms 7% 17.5MB 52%
heapq 모듈을 사용하지 않고 자신이 만들어서 구현
heap 항상 최상단에 가장 작은 수가 오게 만드는 min_heap 구현
heappop은 최상단의 노드를 제거한 뒤 가장 끝의 노드와 자리를 바꿔서 재정렬한다.
heapify는 자식 노드와 비교하여 더 작은 수가 존재한다면 바꾸고 그 자리부터 끝까지 정렬해나간다.
heappush는 배열 가장 끝에 추가해 놓고 부모 노드와 비교하여 작다면 부모와 위치를 바꾸고 배열 처음까지 탐색한다.


# sol3 62~202ms 99~7% 17.5MB 52%
O(nlogn) O(n)
시작 시간에 따라 회의를 정렬하면 회의의 순서를 알 수 있다.
종료 시간은 해당 시작 이벤트가 존재하며 종료 이벤트가 이전에 점유한 방이 이제 비어 있음을 알려준다.
따라서 둘다 정렬된 수가 필요하다.

둘을 분리해서 개별적으로 대하면 종료될 때 어떤 회의가 종료되는지 알 수 없지만 다음과 같은 이유로 괜찮다.
종료가 발생하면 이전에 발생한 어떤 회의가 종료되엇음을 말한다. 우리는 어떤 회의가 종료되는지 신경쓰지 않는다. 회의가 종료되어 그 회의실을 사용할 수 있다는 것만 알면 된다.
종료 타이머가 시작하는 시간보다 작으면 이전에 시작된 어떤 회의가 종료되었음을 알린다. 따라서 지금 시작하는 회의는 사용해도 된다.

'''
class Heap:
    def __init__(self):
        self.arr = []

    def heappop(self):
        idx = len(self.arr)-1
        if idx <= 0:
            return ;
        self.swap(0, idx)
        self.arr.pop()
        self.heapify(0)
        
    def heapify(self, idx):
        left = 2*idx+1
        right = 2*idx+2
        min_idx = idx
        if left <= len(self.arr)-1 and self.arr[min_idx] > self.arr[left]:
            min_idx = left
        if right <= len(self.arr)-1 and self.arr[min_idx] > self.arr[right]:
            min_idx = right
        if min_idx != idx:
            self.swap(min_idx, idx)
            self.heapify(min_idx)

    def heappush(self, val):
        self.arr.append(val)
        idx = len(self.arr)-1
        while 0 <= idx:
            parent = self.parent(idx)
            if 0 <= parent and self.arr[parent] > self.arr[idx]:
                self.swap(parent, idx)
                idx = parent
            else:
                break

    def parent(self, idx):
        if idx == 0:
            return -1
        return (idx-1) //2 

    def swap(self, idx1, idx2):
        self.arr[idx1], self.arr[idx2] = self.arr[idx2], self.arr[idx1]

class Solution:
    def minMeetingRooms(self, intervals: list[list[int]]) -> int:

        # sol1
        # if not intervals:
        #     return 0
        # intervals.sort(key = lambda x : x[0])
        # free_rooms = []
        # import heapq
        # heapq.heappush(free_rooms, intervals[0][1])
        # for interval in intervals[1:]:
        #     if free_rooms[0] <= interval[0]:
        #         heapq.heappop(free_rooms)
        #     heapq.heappush(free_rooms, interval[1])
        # return len(free_rooms)

        # sol2
        # intervals.sort(key = lambda x : x[0])
        # min_heap = Heap()
        # min_heap.heappush(intervals[0][1])
        # for interval in intervals[1:]:
        #     if min_heap.arr[0] <= interval[0]:
        #         min_heap.heappop()
        #     min_heap.heappush(interval[1])
        # print(min_heap.arr)
        # return len(min_heap.arr)
        
        # sol3
        if not intervals:
            return 0
        
        startTime = sorted(i[0] for i in intervals)
        endTime = sorted(i[1] for i in intervals)
        ans = 0
        startPtr = 0; endPtr = 0;
        while startPtr < len(startTime):
            if startTime[startPtr] >= endTime[endPtr]:
                ans -= 1
                endPtr += 1
            ans += 1
            startPtr += 1
        return ans
            

print(Solution().minMeetingRooms([[0,30],[5,10],[15,20]]))
print(Solution().minMeetingRooms([[64738,614406],[211748,780229],[208641,307338],[499908,869489],[218907,889449],[177201,481150],[123679,384415],[120440,404695],[191810,491295],[800783,826206],[165175,221995],[420412,799259],[484168,617671],[746410,886281],[765198,792311],[493853,971285],[194579,313372],[119757,766274],[101315,917883],[557309,599256],[167729,723580],[731216,988021],[225883,752657],[588461,854166],[231328,285640],[772811,869625],[892212,973218],[143535,306402],[336799,998119],[65892,767719],[380440,518918],[321447,558462],[54489,234291],[43934,44986],[11260,968186],[248987,707178],[355162,798511],[661962,781083],[149228,412762],[71084,953153],[44890,655659],[708781,956341],[251847,707658],[650743,932826],[561965,814428],[697026,932724],[583473,919161],[463638,951519],[769086,785893],[17912,923570],[423089,653531],[317269,395886],[412117,701471],[465312,520002],[168739,770178],[624091,814316],[143729,249836],[699196,879379],[585322,989087],[501009,949840],[424092,580498],[282845,345477],[453883,926476],[392148,878695],[471772,771547],[339375,590100],[110499,619323],[8713,291093],[268241,283247],[160815,621452],[168922,810532],[355051,377247],[10461,488835],[220598,261326],[403537,438947],[221492,640708],[114702,926457],[166567,477230],[856127,882961],[218411,256327],[184364,909088],[130802,828793],[312028,811716],[294638,839683],[269329,343517],[167968,391811],[25351,369583],[210660,454598],[166834,576380],[296440,873280],[660142,822072],[33441,778393],[456500,955635],[59220,954158],[306295,429913],[110402,448322],[44523,88192],[231386,353197],[120940,902781],[348758,597599],[329467,664450],[208411,890114],[230238,516885],[434113,602358],[349759,419831],[10689,308144],[94526,180723],[435280,986655],[611999,690154],[75208,395348],[403243,489260],[498884,611075],[487209,863242],[13900,873774],[656706,782943],[53478,586952],[226216,723114],[554799,922759],[467777,689913],[80630,147482],[277803,506346],[532240,976029],[206622,761192],[148277,985819],[10879,807349],[952227,971268],[172074,919866],[239230,384499],[607687,984661],[4405,264532],[41071,437502],[432603,661142],[144398,907360],[139605,360037],[943191,997317],[12894,171584],[382477,800157],[452077,518175],[208007,398880],[375250,489928],[384503,726837],[278181,628759],[114470,635575],[382297,733713],[156559,874172],[507016,815520],[164461,532215],[17332,536971],[418721,911117],[11497,14032]]))

        
        
## Backtracking



### Backtracking

백트래킹은 철저한 검색을 최적화 하는 일반적인 알고리즘이다. 백트래킹으로 해결할 수 있는 일반적인 유형의 문제는 "무언가를 수행할 수 있는 모든 방법 찾기"가 있다. 이러한 유형의 문제에서는 일반적인 모든 솔루션을 검색하는 것보다 문제를 해결하는 더 좋은 방법이 존재한다. 브루트 포스는 가능한 모든 후보를 검색하고 문제의 제약 조건에 대해 확인한다.

문자가 있고 문자를 사용하여 `a-z` 의 문자를 n길이의 문자열을 생성하라는 문제가 주어졌을 때 한 자리에 올 수 있는 문자는 26개이다. 루트가 `""`이라고 가정할 때 루트의 자식은 26개이다. 그리고 그 자식들은 26개가 된다.

n의 길이를 가지는 모든 문자열을 찾기 위해 생기는 문제점에 대해 알아보자. 일단 우리는 모든 정답을 원하지 않는다. 완전 탐색은 모든 문자열을 생성한다. 이 경우 시간 복잡도는 O(k * 26<sup>n</sup>)이 소모된다. 시간 복잡도는 매우 느리게 된다.

백트래킹은 진행하던 중 노드가 유망하지 않으면 그 길을 버리는 방법이다. 이 아이디어는 이진 탐색 트리와 유사하다. 각 서브 트리의 깊이에 따라 지수적으로 증가한다. 백트래킹을 활용하면 이 계산을 줄일 수 있다. 만일 `a-z`에서 모음만 들어간다면 O(5<sup>n</sup>)이 된다. 

*길을 버리는 것을 가지치기 라고도 한다.*

백트래킹은 문제가 모든 솔루션을 찾는 것을 원할 때 가지치기를 통해 시간 복잡도를 지수적으로 줄일 수 있다. 다른 문제에서는 대개 n이 15이하인 경우에 사용할 수 있다. 가끔 인터뷰에서 조건에 대해 듣지 못했을 때 인터뷰어에게 문제의 조건을 명확히 할 수 있다. 

**구현**

백트래킹은 대개 재귀로 구현된다. 많은 백트래킹 문제에서 배열을 만들거나, 변수를 수정해 가면서 무언가를 구축해 나간다.

```pseudocode
function backtrack(curr) {
	if (base case) {
		Increment or add to answer 
		return 
	}
	for (iterate over input) {
		Modify curr
		backtrack(cur)
		etc...
	}
}
```

모든 가능성이 있는 트리를 생각하면 for문을 통해 모든 현재 노드의 자식노드를 통과한다. 수정한 뒤 조건을 확인 후 더 이상 진행하지 않는 것을 백트래킹이라고 한다. 다른 노드로 이동하기 전에 현재 노드의 변경사항을 모두 제거한다. 



### 백트래킹의 생성

* [46. Permutations](https://leetcode.com/problems/permutations/)

  순열은 중복 없이 모든 요소를 포함한다. 재귀를 통해 현재 순열을 만들어 리턴한다.

* [78. Subsets](https://leetcode.com/problems/subsets/)

  모든 하위 셋을 반환하는 문제

* [77. Combinations](https://leetcode.com/problems/combinations/)

  k개가 들어가는 조합을 구하는 문제




## Heaps





### Heaps

힙은 우선 순위 큐로 알려진 데이터 구조인다. 우선 순위 큐는 추상적인 데이터 구조이고 힙은 구현이지만 우리는 종종 두 용어를 같은 의미로 사용한다.

힙은 요소를 저장하는 컨테이너이며 다음 작업을 지원한다.

* 추가 O(logn)
* 제거 O(logn)
* 최소, 최대 요소 찾기 O(1)

힙은 최소 요소 대신 최대 요소를 찾을 수도 있다. 최소 요소를 찾거나 제거하도록 힙이 구성된 경우 이를 최소 힙이라고 한다. 최대 요소를 찾거나 제거하도록 구성된 경우 이를 최대 힙이라고 한다.



힙의 구현 방식

해시 맵과 마찬가지로 주요 프로그래밍 언어는 힙을 지원하므로 구현할 필요는 없다. 알고리즘 문제를 해결하는 측면에서 인터페이스가 구현되는 방식이 아니라 인터페이스에만 관심이 있다. 하지만 해시 맵과 마찬가지로 인터뷰에서 질문을 받는 경우  구현을 이해하는 것이 여전히 중요하다.

힙을 구현하는 방법에는 여러 가지가 있지만 가장 널리 사용되는 방법은 배열을 사용하는 이진 힙이다. 이진 힙은 이진 트리를 구현한다. 아이디어는 힙의 각 요소가 트리의 노드라는 것이다. 루트는 힙에서 가장 작은 요소이며 다음 속성이 모든 노드에서 유지된다. A의 자식인 B는 항상 `A.val <= B.val`이 된다.

또 다른 조건은 트리가 완전 트리여야 한다는 것이다.

트리 자체의 구현은 일반적으로 배열을 사용하고 부모 자식 관계는 다음과 같은 관계를 가진다. 부모의 인덱스가 idx일 경우 자식의 인덱스는 `2idx+1, 2idx+2`에 존재한다. 

많은 문제에서 힙을 사용하면 알고리즘의 시간 복잡도를 다음과 같이 개선할 수 있다. O(n<sup>2</sup>)에서 O(logn)으로 떨어지는 것은 엄청난 계산이다. 힙은 반복적으로 최대값 또는 최소값을 찾아야 할 때마다 훌륭한 옵션이다. 

```python
import heapq

heap = [4,3,1,0,9,10]
heapq.heapifity(heap)
heapq.heappush(heap, 6)
heapq.heappush(heap, 8)
# sorted order 0,1,3,4,6,8,9,10
while heap:
    print(heapq.heappop(heap))
```

```js
// js는 heap 모듈이 존재하지 않음
```



### Heap examples

힙은 반복적으로 최대 또는 최소의 요소를 찾아야 할 때마다 강력한 성능을 보인다.

* [1046. 마지막 돌 무게](https://leetcode.com/problems/last-stone-weight/)

  python은 min-heap만 구현한다. 최대 힙을 구현하기 위해 모든 값을 -로 구현할 수 있다. 

  매 횟수마다 최소 1개의 바위가 부숴지므로 n번 반복할 수 있다. 시작 길이는 n이므로 n번 반복할 때마다 팝(O(1))과 푸시(O(logn))이 반복된다. 따라서 O(nlogn)의 시간복잡도가 들어간다.

* [2208. 배열 합계를 절반으로 줄이기 위한 최소 작업](https://leetcode.com/problems/minimum-operations-to-halve-array-sum/)

  배열에서 최대값을 반으로 줄이면서 계속하여 합을 계산해 절반으로 떨어질 때까지 반복한다.

두 개의 힙

다중 힙을 사용하는 것은 일반적이지 않으며 이를 필요로 하는 문제는 어려운 편이다. 문제가 중앙값을 찾는 경우에 관련하여 생각해보면 좋다. 

* [Sliding Window Median](https://leetcode.com/problems/sliding-window-median/)
* [Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)



### Top-k

인터뷰 문제의 일반적인 유형 중 하나는 문제에 의해 정의되는 k번째 최고, 최상의 요소를 찾도록 요청하는 것이다. 이런 문제를 해결하는 가장 쉬운 방법은 문제의 기준에 따라 정렬한 다음 k요소를 반환하는 것이다. 이 시간 복잡도는 O(nlogn)이 된다.

대신 힙을 사용하여 O(nlogk)로 최상위 k요소를 찾을 수 있다. n > k이지만 실질적으로 빨라지지는 않지만 그래도 작은 개선을 이룰 수 있다.

처음에 최대 힙을 형성하고 힙의 모든 요소를 푸시하는 동안 입력을 반복하고 크기가 초과되면 힙에서 팝한다. 힙의 크기가 제한되기 때문에 모든 힙 작업은 O(logk)가 된다. 이를 반복으로 곱하면 O(nlogk)가 된다. 우리는 최대 힙을 사용하고 문제 기준에 따라 힙에서 팝하기 때문에 팝은 최악의 요소를 제거하므로 최상의 k가 남게 된다.

* [347. 자주 사용되는 상위 K개 요소](https://leetcode.com/problems/top-k-frequent-elements/)

  해시 맵을 사용하여 카운트할 수 있다. 그 뒤 힙에 셋으로 카운트 횟수와 키를 푸시하게 되면 카운트 횟수에 따라 해시맵 키를 정렬할 수 있다.

  최소 힙에서 팝하면 가장 작은 횟수가 작은 요소가 제거된다. 힙의 크기가 k를 초과하면 logk로 팝 된다. 

* [658. K개의 가장 가까운 요소 찾기](https://leetcode.com/problems/find-k-closest-elements/)

  차이의 절대값을 저장하여 순서대로 -를 붙여 민힙에 저장한다. 








## Introduction





### Introduction to Big O

빅 O표기법은 알고리즘의 복잡도를 설명하기 위해 사용되는 표기법이다. 알고리즘의 계산 복잡도는 시간, 공간 두 가지로 나뉜다. 알고리즘의 시간 복잡도는 입력 크기에 비례하여 알고리즘을 실행하는 데 필요한 시간이다. 알고리즘의 공간 복잡도는 입력 크기에 비례하여 실행될 때 필요한 메모리의 양이다.

일반적으로는 더 나은 공간 복잡성보다 더 나은 시간 복잡성을 갖는 데 관심을 가진다.

복잡성은 입력에 따라 변할 수 있는 변수의 함수로 설명된다. 일반적인 변수는 N, 일반적으로 입력 배열 또는 문자열의 길이를 뜻한다.

```
O(n)
O(n^2)
O(2^n)
O(logn)
O(mn)
```

함수는 인수가 무한대 경향이 있을 때 작업, 메모리가 어떻게 증가하는지 설명한다. 변수는 무한대 이므로 상수는 항상 무시된다.

```
O(10n) = O(5n) = O(n)
```

위의 세가지 알고리즘이 있을 경우 10n이 더 많은 연산을 하지만 n이 무한대로 증가하므로 계수는 의미가 없다. 또한 덧셈이나 뺄셈이 있는 경우 항을 무시할 수 있다.

```
O(2^n) = O(2^n + n)
```

최고의 복잡성은 O(1) 입력에 상관없이 일정한 시간, 일정한 공간을 사용하여 항상 동일한 리소스를 사용한다. 일정한 시간 복잡도가 반드시 알고리즘이 빠르다는 것은 아니다. 단지 입력에 관계없이 일정한 리소스를 사용한다는 것을 말한다.



복잡성에 대해 이야기 할 때 일반적으로 세 가지 경우를 사용한다.

최상의 시간, 평균, 최악의 시간

대부분의 경우 세 가지 모두 동일하지만 일부 알고리즘에서는 다를 수 있다. 알고리즘의 시간, 공간 복잡성의 경우 하나만 선택해야 할 경우 최상을 선택하지 마라. 최악이 가장 정확하지만 경우의 차이점에 대해 설명할 수 있어야 한다.

* 시간 복잡도 분석

  ```pseudocode
  for (int num: arr) {
  	print(num)
  }
  ```

  위의 알고리즘은 O(n)의 시간 복잡도를 가진다. 루프를 돌면서 O(1)을 소모한다. 루프가 n번 돌게 되므로 O(1 * n) = O(n)이 된다.

  ```pseudocode
  for (int num1: arr) {
  	for (int num2: arr) {
  		print(num1 * num2)
  	}
  }
  ```

  위의 알고리즘은 O(n ^2)의 시간 복잡도를 갖는다. 

  때때로 작업은 시간 복잡도에 포함되지 않은 알고리즘에 의해 수행된다. 곱셈이 O(1)일 때 곱셈은 숫자가 클 수록 오래 걸리지만 N 배열의 크기와는 아무 문제가 없다. 

  ```pseudocode
  arr length = n; arr2 length = m
  for (int num: arr) {
  	print(num)
  }
  for (int num: arr) {
  	print(num)
  }
  for (int num : arr2) {
  	print(num2)
  }
  ```

  위 알고리즘의 시간 복잡도는 O(2n + m)이다. 하지만 계수는 제외 하므로 O(n + m)이다.

  ```pseudocode
  for (int i=0; i < arr.length; i++) {
  	for (int j=i; j < arr.length; i++) {
  		print(arr[i] + arr[j])
  	}
  }
  ```

  위의 알고리즘의 경우 n + n-1 + n-2 ... 1이므로 정확한 빅 O는 O(n *( n+1) / 2)가 된다. 하지만 상수항은 무시되어야 한다. 따라서 O(n^2)이 된다.

* 대수 시간

  로그는 지수의 역 연산으로 O(logn)이 된다. 매우 빠르다. 일반적인 시간 복잡도는 O(nlogn) 대부분의 문제에서 빠르며 정렬 알고리즘의 시간복잡도가 된다.

  일반적으로 로그의 밑은 2이고 입력이 n인 경우 알고리즘이 x작업을 수행한다면 2^x = n이 표시된다. 로그의 밑은 빅 O에서 실제로 중요하지 않다. 모든 로그는 상수 인수로 관련되기 때문이다.

  O(logn)은 알고리즘 어딘가에서 인풋이 단계마다 일정 퍼센트가 줄어든다는 것을 말한다. 가장 좋은 예시는 이진 탐색이다. 이진 탐색은 O(logn)으로 실행된다. n의 입력 크기가 들어올 때 한 단계가 실행되면 입력은 n/2가 되며 그 다음은 n/4가 된다. 

* 공간 복잡도 분석

  변수를 선언하고 해당 변수에 저장된 데이터를 수정하면 알고리즘이 메모리를 할당한다. 우리는 입력에 사용된 공간을 계산하지 않는다.(입력을 수정하는 것은 옳지 못하다.) 면접관이 요청하지 않는 한 출력에 사용된 공간을 계산하지 않는다.

  ```pseudocode
  int (num : arr) {
  	print(num)
  }
  ```

  위 알고리즘의 경우 공간 복잡도는 O(1)으로 할당된 유일한 공간은 정수 변수이다.

  ```pseudocode
  Array doubleNums = int[]
  for (int num: arr) {
  	doubleNums.add(num *2)
  }
  ```

  위의 알고리즘의 경우 O(n)을 소모한다. doubleNums가 O(n)만큼의 복잡도를 가진다.

  ```pseudocode
  Array nums = int []
  int oneHundredth = n / 100
  
  for (int i=0; i < oneHundredth; i++) {
  	nums.add(arr[i])
  }
  ```

  위의 알고리즘은 O(n)이라는 공간 복잡도를 가진다. nums는 1%만큼을 저장하는데 O(n/100) = O(n)이므로 O(n)이 된다.

  ```pseudocode
  arr length = n; arr length = m
  
  Array grid = int[n][m]
  for (int i=0; i<arr.length; i++) {
  	for (int j=0; j < arr2.length;j++) {
  		grid[i][j] = arr[i] * arr2[j]
  	}
  }
  ```

  위 알고리즘의 공간 복잡도는 O(n*m)이 된다. grid의 사이즈가 n\*m이기 때문이다.

  



### Introduction to recursion

재귀는 문제 해결 방법이다. 코드에서 재귀는 자신을 호출하는 함수를 사용하여 구현된다.

재귀 알고리즘의 반대는 반복 알고리즘이다. 반복 알고리즘은 for, while을 사용하여 반복을 실행하는 반면 재귀 알고리즘은 함수 호출을 사용하여 동일한 논리를 실행한다.

```pseudocode
for (int i=1; i<= 10; i++) {
	print(i)
}
```

재귀로는 다음과 같이 작성된다.

```pseudocode
function fn(i):
	print(i)
	fn(i+1)
	return
fn(1)
```

각 호출마다 i을 호출하고 i+1을 하여 함수를 다시호출한다.

그러나 함수의 종료 조건이 없어서 함수가 계속 호출될 수 있으므로 함수가 호출 되기 전에 종료 조건을 설정해야 한다.

```pseudocode
function fn(i):
	if (i > 10)
		return ;
	print(i)
	fn(i+1)
	return
fn(1)
```

10을 넘어서면 함수는 종료된다.

재귀에 대해 이해해야 하는 코드가 실행되는 순서가 중요하다. 다음과 같은 수도 코드의 출력은 다음과 같다.

```pseudocode
function fn(i):
	if i > 3:
		return ;
	print(i)
	fn(i+1)
	print(f"end of call i = {i}")
	return ;
fn(1)
```

```
1
2
3
end of call i = 3
end of call i = 2
end of call i = 1
```

텍스트를 인쇄하는 행은 역순으로 실행된다. fn(1)은 1을 출력한 후 fn(2)를 실행한다. 그 뒤 fn(2)가 종료 된후 텍스트를 출력한다. 

* 문제 해결

  피보나치 수는 재귀로 해결하는 가장 대표적인 문제이다. `fn = fn-1 + fn-2`이다. 

  ```pseudocode
  fucntion F(n):
  		if n <= 1:
  			return n;
  		return F(n-1) + F(n-2)
  ```

  3일 경우 F(2) + F(1)이므로 F(1) + F(0) + F(1)이 된다. 따라서 2가 된다.

  재귀는 주어진 입력에 대해 해결하려는 문제에 대한 답을 반환하도록 한 다음 기본 사례와 반복 관계를 결정하여 하위 문제를 해결한다.
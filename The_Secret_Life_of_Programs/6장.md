# 입출력과 네트워킹

> 컴퓨터는 외부와 어떻게 상호작용하는가

컴퓨터는 단지 재미로 계산을 수행하지 않고 컴퓨터는 여러 근원에서 입력을 받고 계산을 수행한 다음, 다양한 장치를 통해 출력을 만들어낸다. 컴퓨터는 사람과 통신하거나, 다른 컴퓨터와 통신하거나, 공장을 돌릴 수 있다.

입력과 출력(I/O)에 대해 168페이지 '입력과 출력' 절에서 프로세서 코어로 들어오고 나가는 데이터를 언급하면서 간략히 설명했다. 이런 입출력은 그리 어렵지 않다. 필요한 것은 출력을 위한 래치와 입력을 위한 트라이스테이트 버퍼뿐이다. I/O 장치의 모든 핀이 래치나 버퍼에 연결되고 컴퓨터 CPU가 이 모든 연결을 직접 조작하던 때도 있었다. 

프로세서 가격이 줄어들면서 이런 상황이 달라졌다. I/O 장치에는 자체 마이크로프로세서가 들어 있다. 디지털 출력이 붙은 3축 가속도 센서나 온도 센서를 구입할 수 있다. 이런 장치의 인터페이스는 장치의 명세에 맞춰 바이트를 읽고 쓰는 것만 작용한다. 프로세서가 내장된 장치를 다루는 코드를 작성해본 독자도 있을 것이다.

6장에서는 I/O 장치와 상호작용하는 기술을 다룬다. 그리고 샘플링(sampling)에 대해 설명한다. 실제 세계의 아날로그 데이터를 컴퓨터가 쓸 수 있는 디지털 형태로 바꾸거나, 역방향으로 바꾸려면 샘플링을 해야 한다.





### 저수준 I/O

가장 단순한 I/O는 CPU가 읽거나 쓸 수 있는 비트에 물건을 연결한 형태의 I/O이다. 이런 형태의 I/O가 널리 쓰이게 되면서 점점 더 복잡한 장치로 진화했다. 이번 절에는 I/O의 예를 살펴본다.



* I/O 포트

  포트는 세 가지 레지스터에 의해 제어된다. DDR는 데이터 방향 레지스터(Data Direction register)이다. DDR는 각 핀을 입력으로 쓸지 출력으로 쓸지 결정한다. PORT는 출력 데이터를 저장하는 래치다. PIN은 핀의 값을 읽는다.

  실제로는 살펴본 표준. 적인 구성요소인 디먹스, 플립플롭, 트라이스테이트 버퍼를 다른 방식으로 배치한 것에 지나지 않는다. 

  DDR은 포트에 대한 데이터 방향 레지스터다. 이 레지스터의 어느 비트에 1을 넣으면 그 비트 번호에 해당하는 포트 비트가 출력에 쓰이게 된다. 0을 넣으면 입력이다. PORT는 포트의 출력 부분이다. PORT의 어느 비트에 0이나 1을 넣으면 (해당 비트가 출력 비트로 지정된 경우) 핀의 출력 전압이 0이나 1로 바뀐다. PIN을 읽으면 연관된 핀의 상태를 읽을 수 있다.

  칩에서 데이터를 꺼내거나 데이터를 칩에 읽어 들이는 것은 상당히 쉽다. PIN 레지스터의 비트를 살펴보면 스위치의 상태를 알 수 있다. PORT 레지스터의 PORT 비트에 값을 넣으면 LED를 켜거나 끌 수 있다. LED를 깜빡거리는 간단한 프록르ㅐㅁ을 작성할 수 있다.

* 버튼을 눌러라

  다양한 장치에 어떤 종류든 버튼이나 스위치가 들어간다. 버튼이나 스위치가 설계된 방식으로 인해 컴퓨터가 이들의 값을 읽어들이기는 쉽지 않다. 간단한 푸시 버튼은 두 접점과 버튼이 눌리면 두 접점을 연결해주는 금속 조각으로 이뤄져 있다.

  버튼이 눌리지 않은 경우 풀업 저항이 프로세서의 인터럽트 요청(IRQ : Interrut request) 핀에 연결된 선의 전압을 공급 전압 V까지 올려서 논리 1을 만들어 준다. 버튼이 눌리면 IRQ나 회로가 타지않게 V에서 흘러오는 전류를 제한하면서 IRQ에 논리 0을 공급한다.

  버튼을 눌렀다 떼면 IRQ에 입력되는 신호가 그림과 같으리라 생각하기 쉽다. 하지만 실제로는 다음과 같은 신호가 들어간다.

  ```
  전압 1 --- 0 --- 0 --- 1 : 이상적
  전압 1 -1-0-1-0 ---0---1 : 현실적
  ```

  금속조각이 접점에 닿으면 아주 잠깐 되튕겨 지면서(bounce) 접점에서 떨어진다. 접촉면이 안정될 때까지 이런 되튕김이 여러번 발생할 수 있다. 버튼을 프로세서의 인터럽트 발생 핀에 연결했기 때문에 푸시 버튼을 한 번 눌렀는데 인터럽트가 여러 번 발생할 수 있다. 분명 이는 바람직하지 않기 때문에 버튼을 디바운스(debounce)할 필요가 있다.

  디바운스하는 간단한 방법은 인터럽트 핸들러에 타이머를 설정하고 그 시간이 지나면 버튼 상태를 감지하는 것이다. 이런 접근 방식은 두 가지 방법으로 실현할 수 있다. 첫 번째는 최초 인터럽트 시 타이머를 설정하는 방법이고, 두 번째는 인터럽트가 발생할 때마다 기존 타이머를 새 타이머로 재설정하는 것이다.

  ```
  전압 1 -(1-0-1-0) ---0---1 : (검사)
  ```

  이런 방식도 잘 작동하지만 최선은 아니다. 기계 부품이 낡음에 따라 버튼 바운스 시간이 달라지기 때문에 타이머 값을 정하기 어렵다. 또한 대부분의 장치에는 버튼이 하나 이상 있지만 프로세서에 인터럽트 핀이 그만큼 있을 것 같지는 아늏다. 인터럽트를 공유하는 회로를 만들 수도 있지만 소프트웨어로 구현하는 편이 더 싸게 먹힌다. 대부분의 시스템에는 주기적인 인터럽트를 만들어내는 일종의 타이머가 있다. 이 인터럽트를 이용하며 버튼 디바운싱을 해결할 수 있다.

  어떤 I/O 포트에 연결된 버튼이 8개 있다고 가정하자. 이 I/O 포트의 상태는 INB라는 8비트 unsigned char를 통해 읽을 수 있다. 다음 그림처럼 유한 임펄스 응답(FIR : finite impulse response)필터를 만들 수 있다. FIR은 큐 (queue)이다. 타이머 틱이 발생할 때마다 가장 오래된 값을 버리고 새 값을 넣으면서 각 값을 하나씩 시프트 한다. 그리고 배열 원소들을 OR해서 상태를 만들어내고 원소가 2개(current와 previous) 있는 큐의 current 입력으로 넣는다. current에 값을 넣기 직전에 기존 current값은 previous로 옮긴다. 이제는 current와 previous 상태를 xor 하기만 하면 어떤 버튼이 상태가 바뀌었는지 알 수 있다.

  이 과정은 간단하게 코드로 작성할 수 있다.

  ```c
  unsigned char filter[FILTER_SIZE];
  unsigned char changed;
  unsigned char current;
  unsigned char previous;
  
  previous = current;
  current = 0;
  for (int i = FILTER_SIZE-1; i > 0; i--) {
    filter[i] = filter[i-1];
    current |= filter[i];
  }
  filter[0] = INB;
  current |= filter[0];
  changed = current ^ previous;
  ```

  FILTER_SIZE는 필터의 원소개수다. 이 원소 개수는 버튼의 잡음(바운싱 정도)이 얼마나 많은지와 인터럽트가 얼마나 자주 걸리는지에 따라 결정해야 한다.

* 빛이 있으라

  어떤 종류든 디스플레이가 포함된 장치가 많이 있다. 여기서 디스플레이는 알람시계나 식기 세척기를 말한다. 디스플레이에는 표시등이나 간단한 수치를 표시할 수 있는 경우가 많이 있다.

  가장 흔한 표시 장치는 7세그먼트 디스플레이이다. 여기에는 LED가 7개가 숫자 8의 형태로 나열되어 있고  소수점을 표현하는 LED가 하나 더 붙어있다.

  이 디스플레이에 있는 8개의 LED를 처리하려면 16가지 전기적 접점이 필요하다. 하지만 보통은 16개의 핀을 사용하지 않고 각 LED마다 핀을 하나씩 연결하고 핀 하나에는 모든 LED를 연결한다. LED를 켜거나 끄려면 한 쪽만 제어하면 되기 때문에 공통 연결핀을 함께 사용하면 핀 개수를 줄이고 비용도 아낄 수 있다. 다음은 공통 캐소드(common cathode) 디스플레이를 보여준다. 모든 캐소드가 한꺼번에 연결되고 각 애노드마다 별도의 핀이 배정되기 때문이다.

  ```
  a b c d e f g dp
  | | | | | | | |
  			---
  			 _
  ```

  애노드를 프로세서 출력 핀에 연결하고, 캐소드를 그라운드(ground)나 파워 서플라이(power supply)의 음극에 연결할 수도 있다. 핀에 높은 전압이 걸리면 연결된 LED가 밝아진다. 실전에선 프로세서가 충분한 전류를 제공하지 못하기 때문에 추가로 드라이버 회로를 구성해야 한다.

  이런 디스플레이를 제어하기 위한 소프트웨어는 숫자와 그에 따라 세그먼트의 어떤 LED를 켤지 연관시키는 표뿐이다. 각 디스플레이를 별도의 I/O 포트에 연결할 수 있지만 프로세서가 충분한 수의 포트가 없을 경우 가 흔하다. 해법은 디스플레이의 애노드를 포트 A에 연결하고 캐소드를 B에 연결하면서 디스플레이를 멀티플렉스(multiplex)하는 것이다.

  ```
  프로세서 A ----------------
  							|         |
  					display1, display2
  					   |          |
  프로세서 B1	----          |
  프로세서 B2 --------------
  ```

  디스플에이 애노드는 병렬로 연결된다. 모든 A 세그먼트가 서로 연결되고 모든 B세그먼트가 서로 연결되는 식이다. 각 디스플레이의 캐소드는 자신만의 출력 핀에 연결된다. 어떤 디스플레이 세그먼트가 켜지려면 해당 디스플레이의 애노드가 1인 동시의 캐소드가 0이여야 한다. 왜 그런지 궁금할 것이다. A 세그먼트가 1이고 B 세그먼트가 0이면 세그먼트 A와 B는 켜지지 않는다.  왜 그런지는 디스플레이가 다이오드라서 그렇다.

  이 디스플레이가 작동하게 하기위해 시작의 잔상효과(persistence of vision)를 활용한다. 사람이 이 디스플레이가 계속 켜져 있는 것을 확인하기 위해 디스플레이를 1초에 24간격으로 깜빡인다. 이는 영화나 비디오 같은 움직이는 영상이 작동하는 원리와 같다. 우리가 할 일은 켜져야 하는 디스플에이에 해당하는 캐소드를 0으로 하고 켜져야 하는 세그먼트의 애노드를 1로 설정하는 것이다. 타이머 인터럽트 핸들러를 사용해 짧은 시간으로 디스플레이를 계속 변경하면서 세그먼트를 짧게 켰다 끄면 세그먼트가 계속 켜져 있는 것처럼 보이게 할 수 있다.

* 빛, 동작, 그리고 상호 연동

  어떤 장치에 버튼과 디스플레이가 함께 있는 경우도 종종 있다. 이런 경우 버튼과 디스플레이의 입력을 멀티플렉싱하면 핀을 덜 써도 된다.  예를 들어 4자리 디스플레이가 있고 12개의 버튼이 있을 때 핀을 12개 추가하지 않고 단지 3개만 추가해 디스플레이를 작동할 수 있다.

* 밝기 조절

  알람 시계에는 디스플레이의 밝기를 조절하는 장치가 포함될 수도 있다. 어떻게 밝기를 조절할 수 있을까? 디스플레이의 듀티 사이클(duty cycle)을 조절함으로써 밝기를 조절할 수 있다. 디스플레이를 1/4 시간만 켜져있게 만들거나 1/8시간 만큼만 켜져 있게 만들면 결과적으로 1/4시간 켜져 있는 디스플레이가 1/8시간만큼 켜져있는 디스플레이보다 2배 더 밝아 보인다. 밝기는 디스플레이가 켜져 있는 평균 시간과 관련이 있다. 하지만 듀티 사이클과 사람이 인지하는 밝기의 관계는 선형이 아닐 것이다.

* 그레이의 2<sup>n</sup> 그림자.

  센서를 읽어 모터 바퀴 놉 같은 회전축의 위치를 알아내야 하는 경우가 있다. 회전축에 스위치를 넣거나 광센서가 읽을 수 있는 검은색과 흰색 점을 사용해 위치를 알아낼 수 있다. 어떤 접근 방법을 택하든 축의 위치를 2진수로 인코딩 해야 한다. 우리가 여덟 가지 위치에 관심이 있다면 인코드는 비슷한 형태일 것이다. 인코더는 간단해 보인다. 하지만 기계적인 내성에서 문제점이 생긴다. 제대로 그려진 인코더를 사용하더라도 회로가 각 비트를 읽으며 발생하는 전파 지연으로 인한 문제가 생긴다.  

  벨 전화 연구소의 미국 물리학자 프랭크 그레이(frank gray)는 이 문제를 살펴보다가 각도가 달라질 때 비트가 하나씩만 달라지는 인코딩 방법을 생각해냈다. 3비트 인코더에서 그레이의 이름을 딴 그레이 코드로 각도를 표현하면 `000 001 010 011 100 101 110 111`로 표현할 수 있다. 

* 쿼드러처

  2비트 그레이 코드를 약간 뒤틀면 어떤 대상에 절대적 위치를 알 필요는 없지만 위치가 변했는지와 어떤 방향으로 변했는지를 알 필요가 있는 경우에 써먹을 수 있다. 자동차 대시보드에 있는 볼륨인 놉(knob)이 이런 방식으로 작동한다. 자동차 시동이 꺼져있을 때  볼륨 놉을 돌려서 어떤 위치에 두더라도 라디오 볼륨이 달라지지 않는다는 사실이 이를 보여준다. 이런 변형에는 모두 네 가지 상태가 존재하기 때문에 쿼드러처 인코딩(quadratur encoding)이라고 부른다. 쿼드러처에서는 2비트 그레이 코드 패턴이 여러 번 반복된다. 예를들어 1/4096만큼 작은 변화도 잡아낼 수 있는 저렴한 쿼드러처 인코더가 들어있다. 쿼드러처에는 센서가 2개뿐이다. 두 센서는 각기 다른 비트를 표현한다. 4096가지 위치를 알아낼 수 있는 절대적인 위치 인코더라면 센서가 12개 필요할 것이다. 

  현재 위치와 그 이전 위치로부터 4비트 숫자를 만들어낼 수 있다. 

* 병렬 통신

  병렬 통신은 LED를 켜는 회로를 확장한 것이다. 포트에 여덟 가지 LED를 연결하고 아스키 코드를 발광하게 할 수 있다. 병렬(parallel)이라는 말은 LED 컴포넌트 하나하나마다 별도의 선이 있기 때문에 동시에 모든 컴포넌트를 제어할 수 있다는 뜻이다. 

  병렬 포트(parallel port)가 있는 예전 컴퓨터 모델을 가지고 있는 사람도 있을텐데 USB(Universal Serial Bus : 일반 직렬 버스)가 등장하기 이전에는 프린터나 스캐너에 병렬 코드를 많이 사용했다. 병렬 포트에는 아스키 문자 코드를 전송하기 위한 8개의 데이터 선이 있다.

  하지만 데이터 선을 많이 쓰더라도 데이터 선에 올바른 데이터가 들어 있는 순간을 어떻게 알 수 있을까? ABC라는 글자를 보낼 때 다음 문자가 어떤 문자인지 어떻게 알 수 있을까? AABC 같은 데이터를 보낼 수도 있기 때문에 데이터의 변화만 관찰해서는 이를 알 수 없다. 이를 해결하는 한 가지 방법은 '지금이다'라고 알려주는 또 다른 신호를 추가해야 한다. IEEE 1284에는 이런 목적에 스트로브(strobe)신호가 있다. 스트로브가 0 또는 로우인경우 0번 부터 7번 비트에 있는 데이터가 유효하다.

  한편 한물간 또 다른 병렬 인터페이스로 IDE를 들 수 있다. 예전에는 디스크 드라이브(광학 드라이브)와 통신할 때 IDE를 썼다.

  병렬 인터페이스는 I/O 핀, 커넥터 핀, 선이 많이 필요하기 때문에 가격이 비싸다. 병렬 포트의 커넥터는 핀이 25개이고 케이블도 아주 굵다. IDE는 40개의 선으로 이뤄진다. 한 선에 전달될 수 있는 신호의 속도에는 한계가 있다. 이런 한계를 넘기 위해서는 여러 선이 필요하다.

* 직렬 통신

  통신에 사용하는 전선에는 비용이 들고, 특히 통신 거리가 멀어짐에 따라 전체 비용이 늘어나기 때문에 선을 덜 쓰고 통신할 수 있으면 더 좋다. 전기 신호가 돌아올 경로가 필요하기 때문에 최소한 선이 2개는 필요하다. 그렇다면 한 선에 어떻게 8개 신호를 보낼 수 있을까? 다이어 그램을 보면 각 비트는 서로 다른 선을 통해 전송되지만 각 문자는 서로 다른 시간에 나뉘어 전송된다. 마찬가지로 비트 역시 다른 시간에 나눠서 보낼 수 있다.

  시프트절에서 시프트 레지스터에 대해 설명했다. 송신하는 쪽에서는 스트로브(또는 클록) 신호가 각 비트를 한 위치씩 시프트시키면서 새로 생긴 빈 자리에 선을 통해 내보낸다. 수신하는 쪽에서는 클록이 비트를 한 위치씩 시프트시키면서 새로 생긴 빈 자리에 선을 통해 받은 비트를 채워 넣는다.

  ```
  입력 -> 송신자 시프트 레지스터 --데이터-> 수신자 시프트 레지스터 -> 출력
  ```

  8비트를 세기 위해 카운터를 사용할 수 있고, 얻어낸 값으로 원하는 일을 하면 된다. 이런 접근 방식에는 선이 1가닥이 아니라 2가닥 필요하며 오류가 발생하기도 쉽다. 송신자와 수신자가 서로 동기화(in sync)돼야 한다. 클록을 한 번만 놓쳐도 모든 것이 뒤섞여버린다. 세 번째 선을 추가해서 새로운 문자가 시작한다는 사실을 알려주게 할 수도 있지만 직렬 통신에서는 최소로만 사용하는 게 목표다.

  오래전(1900년대 초) 전신(telegraph)이 타자기(typewriter)와 결합하면서 텔레타이브(teletype)가 생겼다. 텔레타이프는 한 곳에서 타이핑한 내용을 멀리 있는 프린터에서 출력하는 기계를 말한다. 처음에는 주식 시세를 전신에 사용하던 전선을 통해전달하기 위해 텔레타이프 기계가 쓰였다.

  전송할 데이터는 직렬 프로토콜(protocol : 여러 규칙으로 이뤄진 통신 규약)을 통해 신호선 하나로 전달되며, 돌아오는 선이 하나 더 필요하다. 이 프로토콜에서 영리한 부분은 수영 경기와 비슷하게 작동한다는 것이다. 모든 사람은 총 소리가 나면 자신만의 타이머를 시작하고 각 타이머 사이의 차이는 아주 적기 때문에 서로 잘 동기화되어 작동한다. 

  ````
  시작 10100110(첫 번째 글자) - 정지 - 시작 1010100111(두 번째 글자) -- 정지
  ````

  여기에 표현한 선은 아무 일도 일어나지 않을 때 1, 즉 하이 상태를 유지된다. 하이 상태를 마크(mark)라고 부르며, 로우 상태를 스페이스(space)라고 부른다. 이 두 이름은 초기 전신 장비가종이 테이프에 표시(마크)나 빈 공간(스페이스)을 남겼기 때문에 붙여진 이름이다. 선 상태가 로우로 내려가는 부분은 수영 경기에서 출발 신호를 쏘는 것과 같으며 이로 인해 시작 비트(start bit)라고 부른다. 시작 비트 이후 8비트 데이터가 전달되고, 문자의 끝에는 하이 상태인 정지 비트(stop bit)가 2개 붙는다. 각 비트에는 똑같은 시간이 할당된다. 동기화 오류가 발생할 때 송신자가 해야 할 일은 정해진 문자 시간(character time) 동안 조용히 있으면서 수신자가 동기화를 다시 할 때까지 기다리는 것이다. 이때 시간을 나눈 슬롯을 만들고 슬롯마다 각기 다른 비트를 할당해서 데이터를 한 선에 멀티플렉싱한다. 이런 기법을 시간 분할 멀티플렉싱(time division multiplexing)이라고 하며, 시프트 레지스터 대신 셀렉터를 통해 구현할 수 있다. 초당 비트 수 (bits per second)라는 속도를 프랑스 에닞니어 에밀 보도의 이름을 따 보 레이트(Baud rate : 어떤 통신 수단을 통해 전달되는 초당 기호(심볼) 수)라고 부른다.

  텔레타이프는 내부에 아무런 전자 부품이 들어 있지 않고 축을 회전시키는 모터에 의해 작동된다. 회전되는 동안 각 비트에 해당하는 위치에는 여러 캠과 레버, 누름막대 등이 붙어 있고 이들에 의해 금속 활자가 잉크가 묻은 리본을 대리면 종이에 글자가 표시된다. 그래서 선반 위에 있는 장치가 덜컥 거리면 메시지가 들어오고 있음을 알 수 있다. 키보드도 비슷한 방식으로 작동한다. 누른 키에 따라 각기 다른 전기 접점을 움직이도록 축이 돌아가고, 그에 따라 아스키 코드가 만들어진다.

  또 다른 트릭은 반이중(half-duplex) 연결이다.  반이중 통신에서는 송신자와 수신자가 같은 선을 공유한다. 어느 한 순간에는 한쪽만 말할 수 있고, 둘이 동시에 말하면 의미가 통하지 않는 메시지가 생긴다. 그래서 무선 통신 기사들은 메시지를 송신하면 '오버'라는 단어를 붙인다. 무전기를 사용해본 독자는 반이중 통신에 대해 이미 잘 알고 있다고 볼 수 있다. 충돌(collision)은 동시에 둘 이상의 송신자가 메시지를 보내려고 시도해서 데이터가 혼신되는 경우를 뜻한다. 전이중(full duplex) 통신은 선이 2개여서 각기 다른 방향으로 동시에 통신이 가능한 경우를 뜻한다.

  나중에는 이런 통신을 가능하게 해주는 회로가 한 IC로 만들어졌고, 이를 UART라고 부른다. UART는 범용 비동기 수신기-송신기(Universal Asynchronous Receiver - Transmtter)의 약자이다. 소프트웨어로 UART를 구현할 수 잇는데 이르 비트 뱅잉(bit banging)이라고 부른다.

  RS-232라는 표준은 오래된 시리얼 포트의 마크와 스페이스에 사용할 전압 수준을 정의하며, 다른 여러 제어 신호도 정의한다. 이제 RS-232는 USB로 바뀌었지만 잡음 내성을 높이기 위해 미분 신호 방식을 사용하는 RS-485라는 변종이 산업 환경에서 쓰이고 있다. 병렬 IDE 인터페이스는 SATA라는 직렬 버전으로 변경됐다. 최근 전자 장치들은 충분히 빠르기 때문에 과거 병렬로 처리해야만 했던 일을 충분히 직렬로 처리할 수 있다. 게다가 전선은 여전히 비싸다. 전선은 구리를 사용하는 데 채굴 가능한 구리 매장량은 부족해서 이제는 기존 구리 제품을 재활용하는 것이 주된 구리 공급방식이다. 칩은 대부분 실리콘으로 만들어지며, 실리콘은 모래 등에서. 얻을 수 있고 매장량도 아주 많다.

  작은 마이크로컴퓨터에 이르기까지 여러 주변장치를 연결하기 위해 설계된 직렬 인터페이스가 많이 있다. 직렬 인터페이스로는 SPI, I2C , TWC, 원와이어(OneWire)등이 있다.

* 파동에 올라타라

  마크 스페이스 방식의 신호에는 큰 문제가 있는데, 이 문제로 인해 아주 장거리 통신에는 마크-스페이스 방식이 적합하지 않다. 전화선에서는 제대로 작동하지 않는데, 구체적 이유는 너무 어려워서 책의 범위에서 벗어난다. 하지만 과거 전신이 더 나은 기술로 대치된 시점에서는 남아 있는 장거리 통신 기술이 전화와 전파(라디오)뿐이었기 때문에 이 문제가 아주 큰 문제였다. 이런 마크 -스페이스 신호 문제는 라디오를 가능하게 한 트릭을 똑같이 적용해 해결할 수 있다.

  우주에는 다양한 파장이 가득 차 있다. 파도, 음파, 전자기파 등 다양한 파장이 존재한다. 가장 기본적인 파장은 사인파(sign wave)이다. 다른 모든 파형은 사인파를 조합해 만들 수 있다.

  사인파이 높이를 진폭(amplitude)라고 한다. 매초 같은 방향으로 0을 지나치는 횟수를 주파수(frequency)라고 하며 독일 물리학자하인리히 헤르츠(Heinrich Hertz)의 이름을 따서 헤르츠(Hertz)라고 부른다. 헤르츠를 줄여서 Hz라고 쓰며 이는 초당 사이클(cycle per second)와 같은 말이다. 같은 방향으로 0을 지나는 연속된 두 지점 사이의 거리를 파장(wavelength)라고 부른다. 파장과 진폭은 다음과 같은 관계가 있다.
  $$
  \lambda = \upsilon/f
  $$
  이 식에서 l는 파장을 미터로 표시한 값이고 f는 주파수를 Hz로 표시한 값이며, v는 매질 medium(파장을 이동시키는 매개물)에서 파동의 속도를 뜻한다. 전자기파의 경우 속도는 빛의 속도다. 주파수가 높을 수록 파장은 짧아진다. 참고로 피아노의 중간 C음은 261Hz이다. 

  여러 파장에 대해 생각해보면 파장에 따라 특성이 다르다는 사실을 알수 있다. 음파는 아주 멀리 전해지지는 못하며 진공에서 전달되지는 못하지만 건물 구석을 돌아서 전파될 수 있다. 빛은 아주 멀리 갈 수 있지만 벽을 통과하지는 못한다. 어떤 라디오파는 벽을 지날 수 있지만 어떤 라디오파는 그럴 수 없다. 그 중간에는 다양한 변종이 존재한다.

  파도를 타듯 파동에 올라타 볼 때다. 이런 파동을 반송파(carrier)라고 한다. 울리가 전달하려는 신호를 바탕으로 반송파를 마크-스페이스 파형(waveform)처럼 변화시키는 변조(modulation)를 하고 싶다.

  AT&T는 60년대 초반 Bell 103A 데이터 집합을 만들었다. Bell 103A는 네 가지 음향 주파수를 사용하며 전화선을 통해 전달되는 300보(Baud)의 전이중 통신을 제공했다. 연결의 양 끝단은 자신만의 마크 스페이스 음향을 사용했다. 이 마크 스페이스에 의해 주파수가 시프트되기 때문에 이 방식을 주파수 편이 변조(FSK : frequency shift keying)라고 부른다. 그림에서 이를 볼 수 있다.

  ```
  	start 0 1 2 3 4 5 6 7 정지
  f   1   5 1 1 1 1 1 5 1  5 
  ```

  받는 쪽에서는 음향을 다시 마크와 스페이스로 되돌려야 한다. 이를 복조(demodulation)라고 부른다. 변조와 복조를 수행하는 장치를 모뎀(modem)이라고 부른다. 과거를 배경으로 하는영화에서 전화선으로 인터넷에 연결(다이얼 업 연결 dial up connection)하거나 팩스를 보내기 시작할 대 들리는 이상한 잡음은 바로 모뎀이 사용하는 주파수로 인해 생기는 소리다.

* 범용 직렬 버스

  USB(Universal Serial Bus : 범용 직렬 버스)는 그렇게 흥미롭지는 않지만 흔히 쓰이기 때문에 언급해둘만한 가치가 있다. USB는 좀 더 사용하기 어렵고 호환성이 떨어지는 커넥터를 사용하며, 데이터 전송보다는 어쩌다보니 장치 충전에 더 중요한 역할을 한다.

  USB는 90년대 중반까지 종류가 점점 더 늘어나던 PS/2, RS-232, 병렬 포트 등 덩치 큰 커넥터들을 선이 단 4줄인 단일 커넥터로 대부분 대치했다. 네 가지 선은 두 줄의 전력선과 여러 다른 데이터 신호에 사용하기 위한 연선(twited pair)으로 이뤄진다. USB는 앞으로 보게 될 '이 정도 수준에서 멈출 순 없다.'패턴을 따르며 새로운 USB C는 선을 24개 까지 사용하며 예전 병렬 포트와 선의 개수에서 차이가 없다.

  USB는 멋대로 작동하는 버스가 아니다. USB로 연결되는 시스템은 모두 똑같은 지위가 아니며, 모든 종단범(endpoint)을 담당하는 컨트롤러(controller)가 존재한다. 제이터 전송은 구조화 되어 있다. 따라서 그냥 비트를 해석하지 않고 여기서 저기로 옮기지는 않는다. USB는 일반적인 기법을 사용한다. 데이터는 패킷(packet)으로 나뉜다. 패킷에는 헤더(header)와 페이로드(payload 내용물)로 나뉜다. 패킷은 우체국을 통해 전달되는 소포와 같다. 헤더는 기본적으로 바깥에서 찾을 수 있는 정보(어디서 왔는 지, 어디로 가야 하는지)가 들어 있다.

  USB는 음향과 비디오를 동시성 전송(isochronous transfer)을 통해 처리할 수 있다. 종단점은 데이터 전송을 보장하기 위해 자신이 원하는 대역폭(bandwidth 데이터 전송 비율)을 예약해 달라고 요청할 수 있다. 충분한 대역폭이 없는 경우 컨트롤러는 이런 요청을 거부할 수 있다.





### 네트워킹

현대 네트워크의 기원을 알지 못하면 현대 네트워킹 세계에 대해 명확한 그림을 얻기가 힘들다.

네트워크는 일반적으로 두 가지로 구분한다. 근거리 네트워크(LAN : local area network)는 집이나 사무실 같이 좁은 지리적 영역을 묶는다. 광역 네트워크(WAN : wide area network)는 더 넓은 지리적 영역을 묶는다. '좁다'와 '넓다'라는 용어의 명확한 정의가 없으므로 두 용어의 경계는 약간 모호하다.

최초의 네트워크는 전신 네트워크 였고,  전신 네트워크는 나중에 전화 네트워크로 발전했다. 당시에는 컴퓨터가 존재하지 않았기 때문에 처음 네트워크는 컴퓨터 네트워크가 아니였다. 원래의 전화 네트워크는 회선 교환(circuit switch) 방식의 네트워크였다. 회선 교환 방식에서 두 사람 사이에 통화가 이뤄지려면 두 사람의 전선이 실제로 연결되어 회로(circuit)을 만들어야만 한다. '교환 방식'이라는 말은 통화가 이뤄지는 동안만 회선이 만들어지고, 통화가 끝나면 필요에 따라 새로운 회로를 전화국의 스위치를 변경해서 만들 수 있다는 뜻이다.

남아 있는 일반 전화 등의 몇 가지 예외를 제외하면 현재의 전화 시스템는 패킷 교환(packet switch) 방식을 사용한다. 앞 절에서 패킷에 대해서는 설명했다. 통신 내용은 수신자와 송신자 주소가 포함된 패킷으로 나뉜다. 시간 분할 멀티플렉싱을 사용하면 같은 전선을 공유하면서 패킷을 패킷을 보낼 수 이씩 때문에 회로를 더 효율적으로 사용할 수 있다. 전선을 통해 보내는 정보가 단순한 음성 정보보다 더 많아지면서 이런 활용이 가능해졌다.

초기 컴퓨터 네트워크는 냉전 시대의 방어 시스템인 반자동 지상 환경(SAGE : Semi Automatic Ground Environment)의 일부분이였다. SAGE는 전화 네트워크와 모뎀을 사용해 각 지점 사이의 통신을 수행했다.

많은 기관이 60년대 말부터 LAN을 사용해 실험을 하기 시작했다. 예를 들어, 벨 연구소에서 내가 속했던 실험실은 링(ring)이라는 LAN을 통해 부서의 허니웰 컴퓨터에 연결되는 그래픽 터미널을 개발했다. 당시 테이프 드라이브나 프린터 등의 주변장치는 아주 비쌌기 때문에 대부분의 부서에는 이런 장비가 없고 중앙 컴퓨터 센터에 있는 경우가 많았다. 우리 컴퓨터는 모뎀에 연결되어 있었고 직접 연결되어 있지 않은 주변장치가 필요할 때면 컴퓨터 센터를 모뎀으로 연결해야 했다. 시제 이는 WAN이였다. 우리는 출력하고 싶은 내용을 전송할 수 있을 뿐만 아니라 실행하고 싶은 프로그램을 전송할 수도 있었고 컴퓨터 센터는 실행 결과를 가지고 다시 우리 컴퓨터를  호출했다.

비슷한 활동이 여러 연구소나 회사에서 벌어졌다. 여러 가지 LAN이 만들어졌다. 하지만 각 LAN은 자신만의 세상에 존재했고 각기 다른 LAN 사이에는 의사소통할 방법이 없었다. 모뎀과 전화선이 광역 통신의 기반이었다.

벨 연구소에서 개발된 UUCP(Unix to Unix copy)라는 일련의 컴퓨터 프로그램이 1979년 외부 세계로 배포됐다. UUCP를 사용하면 컴퓨터가 다른 컴퓨터에게 데이터를 전송하거나 원격에서 프로그램을 실행할 수 있었다. UUCP는 최초 전자우편 시스템과 유즈넷(USENET) 같은 뉴스 시스템의 근간이 됐다. 이런 시스템은 흥미로운 해킹의 결과였다. 데이터를 미국의 한 끝에서 다른 끝으로 보내는 경우 원하는 목적지에 도착할 때까지 한 기계에서 다른 기계로 넘기면서(hop : linux traceroute을 실행하면 hop으로 넘어가는 기계의 숫자를 볼 수 있다.) 메시지를 전달할 수 있다. 이렇게 하는 이유는 장거리 전화 통화 비용을 피하기 위함이다.

한변 ARPA(Advenced Research Project Agency : 고등 연구 계획국 미국 국방부 산하 부서)는 패킷 스위치 방식의 WAN인 APPANET의 연구 자금을 지원했다. 아파넷은 1990년대 인터넷으로 진화했다. 대부분의 사람들은 인터넷을 그냥 당연한 것처럼 생각하며, 네트워크와 같은 말인 것처럼 생각한다. 하지만 실제 인터넷의 특징은 그 이름에 나타나 있다. 인터넷은 네트워크(net)와 다른 네트워크의 사이(inter)라는 뜻이다. 따라서 인터넷은 네트워크들로 이뤄진 네트워크다. 즉 인터넷은 여러 LAN을 하나로 연결해주는 WAN이다.



* 최근의 LAN들

  요즘은 당연히 여기는 수많은 기술이 제록스 팔로 알토 연구소(PARC : Xerox Palo Alto Research Center)에서 1970년대 발명됐다. 예를 들어 밥 멧칼프는 이더넷(Ethernet)을 발명했는데 이더넷은 먼 거리를 연결할 수 있는 방식은 아니기 때문에 LAN이다.

  최초의 이더넷은 반이중 시스템이었다. 모든 장치(컴퓨터, 카메라, 프린터 등등)가 같은 선에 연결됐다. 각 장치의 네트워크 인터페이스에는 MAC(Media Access Control 매체 접근 제어)주소라는 유일한 48비트 주소가 부여됐고 요즘도 여전히 MAC이 쓰인다. 데이터는 약 1,500바이트 짜리 프레임(frame)이라는 이름의 패킷으로 구성된다. 프레임에는 송신 주소, 수신 주소, 오류 검증이 포함된 헤더가 페이로드와 함께 들어간다.

  보통 어떤 장치가 이야기하면 같은 선에 연결된 그 밖의 장치들은 이것을 들을 수 있다. 하지만 프레임의 MAC 주소가 자신의 주소와 일치하지 않는 장치는 데이터를 무시한다. 모든 장치가 어떤 일이 벌어지고 있는 지 들을 수 있기 때문에 다른 장치가 이야기하는 것을 들은 장치는 아무 말도 하지 않는다. 하지만 둘 이상의 장치가 말하려 시도하면 앞에서 본 반이중 통신의 경우 마찬 가지로 패킷이 서로 엉키면서 충돌이 발생한다. 멧칼프의 발명에서 큰 혁신은 바로 랜덤 백오프 후 재시도(random back-off and retry)이다. 말하고 싶은 장치는 충돌이 발생하면 임의의 시간을 잠깐 기다린 다음 다시 말하려 시도한다.

  이더넷은 요즘도 여전히 쓰이고 있다. 다만 요즘 쓰이는 버전은 반이중 버전이 아니다. 요즘은 각 장치가 라우터(router)라는 장치에 연결되며 라우터는 어떤 장치가 어떤 선에 연결되어 있는 지를 기억하고 패킷을 정확히 배달해준다.

  랜덤 백오프를 사용해 장비들이 통신선을 공유하게 해주는 장치를 허브(hub)라고 부른다. 허브에서는 동시 통신이 불가능하기 때문에 네트워크(대역폭)를 연결된 모든 장비가 서로 나눠서 사용한다. 반면 장비별로 독립적인 패킷을 전달해주는 장치를 보통 스위치(switch)라고 부른다. 라우터는 보통 여러 허브나 스위치, 라우터를 연결하면서 패킷의 주소에 따라 정확히 패킷이 전달돼야만 하는 다른 라우터나 스위치, 허브 등으로 패킷을 전달한다. 그래서 더 이상 충돌이 열리지 않는다.

  

  > TCP / IP

  전송 제어 프로토콜 / 인터넷 프로토콜(TCP / IP Transmission Control Protocol / Internet Protocol)은 인터넷이 사용하는 두 가지 프로토콜이다. IP는 패킷을 한 곳에서 다른 곳으로 옮겨주며, 이 패킷을 데이터그램(datagram)이라고 부른다. 이는 마치 컴퓨터를 위한 전신과 같다. 실제 전신과 마찬가지로 IP를 사용해 메시지를 보낸 송신자는 수신자가 메시지를 언제 받는 지 알 수 없고 심지어는 메시지를 제대로 받았는 지 여부도 알 수 없다. TCP는 IP 위에 만들어졌고 패킷이 제대로 전달됐는지 확실히 보장해준다. 여러 패킷이 각기 다른 경로로 전달됨으로 인해 시간이 아주 오래 지난 다음에야 순서가 뒤바뀐 패킷(이전에 송신됐지만 수신이 늦어진 패킷)이 도착할 수도 있기 때문에 배달 보장은 아주 복잡한 작업이다.

  > IP 주소

  인토넷상의 각 컴퓨터에는 IP 주소(IP address)라는 유일한 주소가 할당되어 있다. MAC 주소와 달리 IP 주소는 하드웨어에 묶여 있지 않아서 변경될 수 있다. IP 주소 시스템은 계층적인 시스템으로, 주소 중 일부분(주소 블록)을 누군가에게 할당하면, 그 누군가는 다시 자신에게 할당된 주소 중 일부 블록을 다른 누군가에게 할당하는 식으로 이뤄진다. 이런 할당 과정은 누군가 장치에 구체적인 주소를 할당해줄 때까지 반복된다.

  인터넷은 대부분 IPv4 즉 IP 버전 4에서 이뤄진다. IPv4는 32비트를 사용한다. 주소는 `xxx.xxx.xxx.xxx`라는 옥텟(octet) 표기를 사용해 표현된다. 여기서 `xxx`는 32비트중 8비트를 사용한다. 전체 40억 개 정도의 주소를 사용할 수 있지만 이는 충분치 않다. 요즘은 누구나 데스크톱, 랩탑, 휴대폰 등등에 대한 IP 주소를 할당하기 때문에 할당할 수 있는 주소가 남아 있지 않다. 따라서 세계는 점점 128비트 주소를 사용하는 IPv6쪽으로 나아가고 있다.

  > 도메인 이름 시스템

  장치의 IP 주소가 바뀔 수 있다면 어떻게 어떤 장치의 현재 실제 주소를 찾을 수 있을까? 이 과정을 도메인 이름 시스템(DNS : Domain Name System)이 수행한다. DNS는 전화번호부와 비슷하다. DNS는 이름을 주소로 바꿔준다. DNS는 whitehouse.gov라는 이름의 IP 주소가 지금 23.15.93.167이 라는 사실을 기억하고 있다. DNS는 휴대폰 주소록 같은 일을 하며 직접 최신 정보를 유지해야 하지만 DNS는 주소가 바뀌는 경우를 알아서 잘 처리해준다는 점이 다르다.

  > 월드 와이드 웹

  TCP/IP 위에 만들어진 여러 프로토콜이 있다. 예를 들어 SMTP(Simple Mail Transfer Protocol : 단순 우편 전달 프로토콜)는 전자우편 시스템이 작동하는 기반 프로토콜이다. 이런 여러 프로토콜 중에 가장 많이 사용되는 프로토콜은 HTTP(HyperText Transfer Protocol)이다. 보안이 강화되어 안전하다는 뜻의 형용사 secure의 첫글자가 추가된 HTTPS와 더불어 웹 페이지 전송을 책임진다.

  하이터텍스트는 단순히 링크가 붙은 텍스트를 뜻한다. 미국 엔지니어 베너바 부시가 이 아이디어를 1945년 생각해냈다. 하지만 세른(CERN)의 팀 버너스리 경이 물리학자들 간의 정보 교환을 위해 월드 와이드 웹을 발명할 때까지는 하이퍼텍스트가 그리 널리 쓰이지 않았다.

  HTTP 표준은 웹 브라우저(web browser)가 웹 서버(web server)와 상호작용하는 방법을 정의한다. 웹 브라우저는 웹 페이지를 볼 때 사용하는 프로그램이다. 웹 서버는 요청한 페이지를 제공한다. URL(Uniform Resource Locator : 일관된 자원 위치 지정자)이라는 웹 브라우저 주소창에 입력하는 웹사이트 주소에 따라 웹 페이지를 얻을 수 있다. URL에는 원하는 정보를 얻을 수 있도록 인터넷상의 컴퓨터에 대한 도메인의 이름과 이 컴퓨터 안의 어디에서 정보를 찾아야 할지에 대한 설명이 들어간다.

  웹 페이지는 보통 HTML(HyperText Markup Languege)로서 존쟇나다. HTML은 웹에서 가장 많이 쓰이는 콘텐츠 기술 언어다. 시간이 지남에 따라 HTML에 여러가지 다양한 기능이 들어가고 상당히 복잡해졌다. 나중에 더 자세히 다룬다.

  

  

  ### 아날로그 처리 방법

  오디오부터 텔레비전에 이르기까지 수많은 엔터테인먼트 장치에 컴퓨터가 들어간다. 디지털 사진을 일정 수준 이상으로 확대하면 더 이상 사진 같아 보이지 않는 다는 사실을 깨달았을 것이다. 실제로 듣는 소리나 보는 빛은 연속적이지만 컴퓨터에는 연속적인 대상을 저장할 방법이 없다. 그래서 데이터의 샘플(sample)을 취해야 한다. 샘플을 취한다는 말을 샘플링이라고 한다. 저장한 데이터를 다시 영상이나 빛으로 보여주려면 샘플링 데이터로부터 아날로그 신호를 다시 만들어야 한다.

  샘플링은 새롭지 않다. 무성 영화 시절에도 영화 화면은 1초당 16프레임을 샘플링해 만들어졌다. 샘플링을 다루는 이산 수학(discrete mathmatics)라는 분야가 있을 정도다. 물론 샘플링은 이산적으로 이뤄져야 한다.

  아날로그의 디지털의 차이는 이전에 설명했다. 이 책은 디지털 컴퓨터에 관한 책이며 일상에 필요한 실제 응용에서는 컴퓨터로 아날로그 신호를 만들거나 아날로그 신호를 분석하거나 둘 다 해야하는 경우가 있다. 이제 어떻게 하는 지 알아보자.

  * 디지털을 아날로그로 변환

    디지털 숫자를 사용해 어떻게 아날로그 전압을 만들 수 있을까? 무신경하지만 올바른 답으로 DA 변환기(digital to analog converter)를 사용한다는 답을 이룰 수 있다.

    LED를 I/O 포트에 연결하는 방법을 다시 살펴보자. 포트에 여덟 핀 각각을 LED에 연결했다. 이제 아홉 가지 세기(다 끈 경우 ~ 다 킨 경우)의 빛을 낼 수 있다. 하지만 8비트로 9가지의 수준을 만들어냈다면 비트를 잘 활용했다고 말하기 어렵다. 8비트를 사용하면 256 수준의 빛을 만들어낼 수 있어야 한다.

    ```
    port 8 128 LED
    port 7 	64 LED
    port 6  32 LED
    ...
    port 1   1 LED
    ```

    위와 같은 경우는 LED가 많이 든다. 위 회로를 보면 포트가 올라갈 때마다 2배의 밝기를 내는 식이다.

    이 예제에서는 DA 변환기의 동작을 명확히 보여주기 위해 LED를 사용했다. 실제 DA 변환기(D/A or DAC)는 빛이 아니라 전압을 만들어 낸다. 해상도(resolution)이라는 용어는 DAC가 만들어내는 단계 수를 느슨히 표현할 때 쓰인다. DAC가 10비트 해상도라면 실제로는 1/2<sup>10</sup>가지씩 수준을 변경할 수 있다는 뜻이기 때문이다. 제대로 말하자면 해상도는 DAC가 만들어낼 수 있는 최대 전압을 단계 수로 나눈 값이어야 한다. 예를 들어 10비트 DAC가 최대 5V를 만들어낼 수 있다면 해상도는 대략 0.005V다.

    DAC를 사용해 아날로그 파형을 만들 수 있다. 오디오 플레이어나 음악 신디사이저가 이런 식으로 작동한다. DAC 입력을 일정한 비율로 변경하면 파형을 만들 수 있다. 예를들어 8비트 DAC를 포트 B에 연결하면 톱니 파형을 만들 수 있다.

    더 복잡한 파형을 만들기 위한 장치에는 데이터를 써넣기 위한 메모리가 들어 있는 경우가 많다. 장치는 추가 회로를 통해 메모리에 있는 데이터를 읽는다. CPU가 수행하는 다른 작업과 무관하게 데이터를 일정한 비율로 읽어서 처리하기 위해 FIFO(First In First Out)설정을 만들어서 이를 구현한다. FIFO는 큐와 마찬가지라는 점에 유의하라.

    ```
    데이터 버스 -입력> ((높은 워터마크) 메모리 (낮은 워터마크)) -출력> DAC -> 아날로그 출력
    ```

    FIFO 메모리와 관련한 두 가지 트리거가 있다. 높은 워터마크(high water mark)와 낮은 워터마크(low water mark)는 각각 최고수위선과 최저 수위선에서 따온 용어다. 낮은 워터마크는 FIFO가 거의 빈 상태가 될 경우 인터럽트를 발생시킨다. 높은 워터마크는 FIFO가 거의 꽉 찾을 때 인터럽트를 발생시킨다. 이런 방법을 사용해 고수준의 소프트웨어에서는 일정한 비율로 연속적으로 출력이 일어나도록 메모리를 채울 수 있다. 워터마크보다 낮아지면 데이터를 채워 넣고 워터마크에 이르면 데이터를 내보낸다. FIFO는 각기 다른 속도로 동작하는 여러 요소를 서로 결합할 때 아주 유용하다.

  * 아날로그를 디지털로 변환

    AD 변환기(analog to digital converter)는 A/D or ADC라고도 쓰는데, DAC보다 더 복잡하다. 첫 번째 문제는 값을 측정할 수 있도록 아날로그 신호의 현재 값을 흔들리지 않게 안정적으로 찹아내는 것이다. 입력 파형의 샘플을 취할 필요가 있다. 디지털화한 파형이 아날로그 파형과 닮으려면 여러 번 샘플을 얻어야 한다. 샘플 앤드 홀드(sample and hold)라는 회로를 사용해 아날로그 파형의 값을 받아낼 수 있다. 샘플 앤드 홀드는 디지털 래치의 아날로그 버전이라고 할 수 있다.

    ```
    아날로그 입력 -> 저장 탱크 -> 아날로그 샘플
    ```

    스위치를 통해 샘플을  얻으면 아날로그 신호의 현재 값이 저장 탱크에 저장된다. 이제는 저장 탱크에 안정적인 값이 들어 있기 때문에 이를 측정해서 디지털값을 만들어낼 수 있다. 이를 위해 어떤 문턱값과 신호를 비교하는 장치가 필요하다. 다행히 두 전압 중 어느 쪽이 더 높은지를 알려주는 비교기(comparator)라는 회로가 있다. 비교기는 문턱값을 선택할 수 있는 논리 게이트와 비슷하다.

    아날로그 비교기의 생김새는 다음과 같다.

    ```
    -> +
    	   \
    	     -> out
    	   / 
    -> - 
    ```

    비교기의 + 입력 신호가 - 입력 신호보다 더 크거나 같으면 출력이 1이고, 그렇지 않으면 0이다.

    비교기를 여러 기준 전압(reference voltage)과 함께 연결해 쌓으면 플래시 변환기(flash converter)를 만들 수 있다.

    ```
    샘플 앤드 홀드에서 오는 신호 -> -> (1.0) - D1
    												|
    												 -> (0.5) - D0
    ```

    결과를 번개같이 빠르게 만들어내기 때문에 플래시 변환기라고 불린다. 위의 경우 0.5보다 낮은 전압의 경우 출력이 00이다. 0.5보다 높고 1.0보다 낮으면 01 1.0보다 높으면 11이다. 이런 방식도 DAC와 같이 비트를 효율적으로 사용하지 못한다는 문제점이 있다. 그리고 비교기를 많이 써야 하기 때문에 상대적으로 플래시 변환기의 가격이 비싸다는 단점도 있다. 비트를 더 효율적으로 사용하는 더 싼 ADC를 어떻게 만들 수 있을가?

    플래시 변환기는 비교기마다 다르게 고정된 몇 가지 기준 전압을 사용한다. 기준 전압을 변화시킬 수 있다면 비교기를 하나만 써도 될 것이다. 이런 기준을 얻는 방법은 바로 DAC에 있다.

    ```
    아날로그 입력 -> 저장 탱크 -> ADC ->  -> 완료
    													|		|
    											기준 전압---															
    ```

    저장 탱크에서 나온 샘플값을 DAC의 값과 비교하기 위해 비교기를 사용하는 회로를 보여준다. 샘플값이 DAC 값과 같아질 때까지 카운터가 수를 센다. 샘플값과 DAC 값이 같아지면 비교기의 출력이 0이 되면서 카운터가 비활성화되므로 원하는 값을 얻고 끝난다. 카운터에는 샘플을 디지털로 변환한 값이 들어있다.

    아날로그 신호는 왔다갔다 하지만, 샘플을 취한다음 저장 탱크의 출력은 안정적이다. 그 후 카운터를 0으로 설정하고 DAC의 출력과 샘플링된 값이 같을 때까지 수를 센다. 두 값이 같아지면 카운터가 멈추고 원하는 변환이 끝난다.

    DAC 출력이 마치 경사로를 올라가는 것처럼 변하기 때문에 이런 ADC를 램프 변환기(ramp converter)라고 부른다. 램프 변환기의 문제는 신호에서 얻은 샘플의 크기에 선형으로 비례하는 시간이 걸리기 때문에 변환에 오랜 시간이 걸린다는데 있다. 샘플이 최댓값이고 ADC가 n비트라면 최대 2<sup>n</sup>클록이 걸려야 변환이 끝난다.

    이를 우회하는 방법으로 연속 추정 변환기(successive approximation converter)가 있다. 이 변환기는 하드웨어로 이진 검색(binary search)을 진행한다.

    첫 클록에 DAC를 전체 범위의 절반으로 설정한다. 이 값이 샘플값보다 작으면 DAC 값을 전체 범위의 1/4만큼 더 증가시킨다. 만약 이렇게 변경한 값이 샘플값보다 너무 크면 DAC 값을 전체 범위의 1/8만큼 더 감소시킨다. 이렇게 바꾼 값이 샘플값보다 더 낮으면 다시 전체 범위의 1/16만큼 DAC 값을 더 증가시킨다. 최악의 경우 log<sub>2</sub>N 클록이 걸리는데, 이정도도 상당히 향상된 결과다.

    DAC에 해상도라는 말을 사용했던 것과 비슷하게 ADC에도 사용한다. ADC의 기호는 다음과 같다.

    ```
    v(in) -> DAC -> D(o-n)
    ```

  * 디지털 오디오

    일차원으로 샘플링(sampling)을 하면 오디오를 디지털화할 수 있다. 이 말 은 일정 시간 간격으로 신호의 진폭이나 높이를 측정한다는 뜻이다. 사인파를 보면 일정한 샘플링 주파수(sampling frequency)로 사각파(suare wave)을 얻을 수 있고, 상승 엣지(rising edge)마다 A/D를 사용해 신호의 높이를 기록할 수 있다.

    샘플이 있으면 이를 D/A에 공급해서 원래의 신호를 재구성할 수 있어야 한다. 시도해보면 사각파를 만들 수 있다. 파형이 왜곡 되었다면 샘플을 더 많이 만들어서 개선해야 한다. 푸리에 변환을 통해 주파수에 따른 그래프를 그릴 수 있다.

  * 디지털 이미지

    시각 이미지는 2차원 공간을 샘플링해야 하기 때문에 오디오보다 더 복잡하다. 디지털 이미지는 그림 요소(picture element) 또는 픽셀(pixel)로 이뤄진 직사각형 배열로 표현된다. 컬러 이미지에서 각 픽셀은 RGB값으로 표현된다. 오늘날 일반적인 디스플레이는 RGB에 각각 8비트를 사용한다. 

    컴퓨터는 가산(additive) 혼합 색 시스템을 사용해 색을 표현한다. 삼원색을 여러 비율로 혼합해 모든 색을 만든다. 인쇄에 쓰이는 감산(subtractive)색 시스템과는 다르다. 감산에는 청록색, 자홍색, 노란색을 원색으로 사용한다.

    이미지를 샘플링하는 작업은 이미지 앞에 모눈이 달린 창을 놓고각 네모칸의 색을 기록하는 것과 비슷하다. 이 작업은 실제로는 포인트 샘플링(point sampling)으로 인해 더 복잡하다. 포인트 샘플링은 정사각형 전체의 색을 기록하는 대신 정사각형의 중심 색을 기록한다는 뜻이다.

    더 자세하고 높은 해상도를 사용하면 샘플링한 이미지가 더 보기 좋다. 하지만 해상도가 높아지면 데이터양도 크게 늘어난다. 그렇지만 고해상도 화면에서도 삐죽삐죽한 모서리를 볼 수 있다. 나이퀴스트 이론에 따르면 언더샘플링과 에일리어싱의 결과다. 오디오에서와 마찬가지로 필터링이 도움이 될 수 있다. 필터링을 할 수 있는 방법으로는 슈퍼샘플링(supersampling) 즉 한 정사각형 안에서 여러 지점의 색을 얻어서 평균을 내는 방법이 있다.

    이렇게 샘플링한 이미지는 부풀어 오른 것 같아 보이고 좋아 보이지 않는다. 하지만 이미지에서 멀리 떨어져서 보면 그렇게 나빠 보이지 않는다. 좀 더 생각해보면 슈퍼샘플링은 오디오에서 본 것 처럼 샘플링 비율을 높이는 것과 같은 효과임을 알 수 있다.

    우리가 사용하는 이미지는 점점 커지고 있고 그에 따라 엄청난 공간을 차지한다. 전 세계의 모든 사진과 비디오를 저장하기에 충분한 저장장치가 존재할 수 있는지는 확실하지 않다. 오디오와 마찬가지로 이미지도 같은 메모리에 더 많이 저장하고 네트워크를 통해 더 빨리 전송하고 싶기 때문에 공간을 덜 차지했으면 한다. 이런 목적을 압축을 통해 달성할 수 있었다.

    현재 가장 일반적인 이미지 압축 방법은 JPEG로 연합 사진 전문가그룹(Joint Photographic Experts Group)의 표준 압축 방식이다. JPEG이 작동하는 방식은 이웃한 픽셀의 색이 서로 비슷할 가능성이 높기 때문에 개별적인 픽셀의 색을 저장하는 대신 이웃한 픽셀의 색에 대한 표현을 저장하는 방식으로 이뤄진다고 대강 이해할 수 있다. 카메라에서 저장하는 이미지의 품질을 설정하는 옵션을 볼 수 있는 데 이런 설정에서는 '실물에 가깝다'라는 정의를 조절할 수 있다. 이는 스택 절에서 다룬 내용의 컬러 버전이다.

    JPEG는 손실 오디오 압축과 비슷한 방식으로 사람의 인지 방법에 대한 지식을 활용한다. 예를 들면 두뇌는 색 변화보다는 밝기 변화에 더 민감하다는 사실을 활용한다.

  * 비디오

    다차원 공간을 한 차원 더 높인 것으로 비디오는 2차원 이미지를 일정한 시간 간격으로 샘플링한 시퀀스다. 필요한 시간 간격은 사람의 시각 시스템의 기능에 따라 결정된다. 오래된 영화는 초당 24프레임(fps : frame per second)으로 이미지를 샘플링했지만 요즘 사람들은 48fps 정도가 되면 행복해 한다.

    비디오를 샘플링하는 것은 이미지를 샘플링하는 방식과 그리 다르지 않다. 다만 여러 아티팩트가 시각적으로 거슬리기 때문에 이를 최소화할 필요가 있다. 문제는 물체가 움직이기 때문에 이미지의 샘플링 아티팩트가 제자리에 머물러 있지 않는다는 데 있다.

    연속적으로 움직이는 이미지가 존재한다면 이미지가 변하는 정도가 프레임당 픽셀보다 조금 작기 때문에 샘플링할 때마다 각기 다른 이미지가 생긴다. 각 이미지는 같은 이미지를 근사한 것이지만 각 근사는 서로 다르다. 이런 이유로 인해 도형의 윤곽을 나타내는 모서리가 어리어리해지고 눈에 거슬러 보인다. 슈퍼샘플링을 활용한 필터링을 하면 이런 불쾌한 시각적 아티팩트를 줄일 수 있다.

    비디오는 이미지나 오디오보다 훨씬 많은 정보를 만들어낸다. UHD 비디오의 해상도는 3840 * 2160 픽셀이다. 이를 픽셀당 3바이트로 곱하고 초당 60프레임을 곱하면 약 15억 바이트/초 라는 어마어마한 데이터 비율을 얻는다. 분명 압축이 중요하다. 

    비디오 프레임과 프레임 사이에 이미지 중 아주 일부분이 변한다는 관찰이 비디오 압축의 핵심이다. 

    프레임이 변할 때는 이미지의 일부분만 변하므로 변경된 영역의 데이터만 필요하다면 더 적은 데이터를 저장하거나 송신할 수 있다. 이런 기법을 움직임 보상(motion compensation)이라고 한다.

    비디오를 원본 이미지로부터 변화된 내용의 집합으로 표현하는 방식의 문제는 때론(원본 데이터가 개졌거나 원본 데이터를 전송 받지 못한 경우) 데이터가 왜곡된다는 점이다. 디지털 TV를 보거나 고장 난 디스크를 플레이하다가 화면이 네모난 블록 단위로 보이는 것은 이런 이유다.

    데이터를 복구할 방법이 필요하다. 정기적으로 데이터에 키프레임(keyframe)을 추가하는 방식으로 이를 해결한다. 키프레임은 완전한 이미지이므로 오염된 데이터가 누적되면서 생긴 이미지가 손상된 경우라도 다음 키프레임에 전체 이미지를 복구할 수 있다.

    프레임 사이의 차이를 감지하는 알고리즘은 복잡하며 계산이 아주 많이 필요하다. MPEG4 등의 새 압축 표준은 레이어링(layering)을 지원한다. 레이어링은 최근에는 컴퓨터로 생성된 비디오가 많다는 사실을 활용한다. 레이어링은 레이어 간의 각기 다른 그림을 중첩 시켜서 비디오 이미지를 만들어낼 수 있다.





### 휴먼 인터페이스 장치

컴퓨터는 대부분의 시간을 컴퓨터끼리 메시지를 주고받는데 사용하고 가끔 다른 사람에게 이야기한다. 이번 절에서는 컴퓨터가 사람과 상호작용하는 방법을 살펴본다.



* 터미널

  얼마 되지 않은 과거에는 디스플레이나 터치스크린은 상상하기 힘든 사치품이었다.

  종이에 정해진 양식으로 데이터나 프로그램을 입력해야만 컴퓨터와 의사소통할 수 있었던 시절이 있었다. 이런 코딩 양식을 누군가에게 가져가면 이 사람은 키펀치를 사용해 양식을 펀치카드 뭉치로 만들어줬다. 이 카드를 조심히 가져가 컴퓨터 오퍼레이텅에게 건대면 오퍼레이터는 카드 뭉치를 리더에 넣어 컴퓨터가 읽게 해서 프로그램을 실행했다. 이런 접근 방법을 배치 프로세싱(batch processing)이라고 한다. 컴퓨터가 아주 비싸고 느리고 컴퓨터를 실행하는 시간이 귀했기 때문에 프로그램이 카드에 펀치되는 동안 다른 사람의 프로그램을 컴퓨터가 실행할 수 잇게 하려고 이런 방식을 활용했다.

  컴퓨터는 점점 빨라지고 저렴해졌다. 컴퓨터의 실행시간은 덜 희소해졌다. 사람들이 컴퓨터를 테레타이프에 연결하기 시작했다. 텔레타이프는 선의 끝에 연결됐기 때문에 터미널(terminal)이라고 불렀다.

  작은 컴퓨터를 계속 바쁘게 돌리기 위해 시분할(time sharing)이 발명됐다. 그렇다. 컴퓨터는 휴양지 호텔 방처럼 고객이 사용할 차례가 아니면 다른 사람의 방처럼 계속 사용되었다.

  시분할 시스템에는 컴퓨터에서 실행되는 운영체제(OS : Operating System)라는 프로그램이 있다. 운영체제 프로그램은 마치 호텔 예약 담당자 같은 일을 한다. 운영체제는 컴퓨터의 여러 자원을 각 사용자에게 배정해준다. 컴퓨터를 쓸 순서라면 다른 사용자의 프로그램은 디스크로 스왑 아웃되며 프로그램은 디스크에서 메모리로 스왑 인되어 정해진 시간 동안 잠깐 실행된다. 이런 일이 충분히 발리 일어나면 나만 컴퓨터를 사용하는 겉 같이 느껴진다. 물론 컴퓨터를 공유하는 사용자가 늘어나거나 프로그램이 실행하는 작업이 너무 복잡해서 컴퓨터나 자원이 바빠지면 문제점이 드러나기 시작한다. 어느 시점이 되면 운영체제가 프로그램을 스왑 인 하고 스왑 아웃하는 데 소모하는 시간이 사용자 프로그램을 실행하는 시간보다 더 길어지는 스레싱(thrashing) 현상이 일어난다.

  사용자가 많아서 스레싱이 발생하면 시분할 시스템이 아주 느려진다. 따라서 다른 사람들이 모두 집에 돌아간 뒤에 컴퓨터를 차지하기 위해 프로그래머들이 밤 늦게 일을 하기 시작했다.

  시분할 시스템은 컴퓨터가 한 번에 하나 이상의 작업을 실행하는 것 같은 착각을 불러일으키기 때문에 멀티태스킹(multitasking) 시스템이다. 갑자기 많은 터미널이 같은 컴퓨터에 연결되기 시작했기 때문에 컴퓨터가 어떤 작업이 어떤 사람에게 속했는 지 구분하기 위해 사용자(user)라는 개념이 생겨났다.
  
  하지만 터미널은 여전히 종이에 내용을 출력 (hard copy)해 왔다. 하드 카피는 상당기간 텍스트만 출력할 수 있었다. 
  
* 그래픽 터미널

  하드 카피 터미널에서 멀어져야할 이유가 많이 있었다. 특히 속도, 신뢰성, 소음 등이 주된 이유였다. 당시에도 스크린이 존재했다. 이제 화면을 컴퓨터에 사용할 수 있게 해야 할 차례였다. 전자기기의 발전이 느려서 이런 변화도 늦게 일어났다. 당시 메모린느 너무 느리고 너무 비쌌다.

  그래픽 터미널은 원래 흔히 CRT라고 부르는 음극 선관(cathode ray tube)라는 진공관의 변형으로 만들어졌다. CRT 유리의 내부에는 화학적인 인광물질이 발라져있다. 이 인광물질에 전자가 부딪히면 빛이 난다. 그리드 (또는 편향판 deflection plate)가 여럿 있으면 인광물질 위에 그림을 그릴 수 있다. 이는 마치 원하는 위치로 공을 보낼 수 있는 천재 타자와 같다.

  이런 디스플레이가 작동하는 방법은 두 가지가 있다. 편향판 버전은 정전기 현상과 같은 원리인 정전 편향(electrostatic deflection)을 사용한다. 다른 방법은 전자기를 사용한 버전이며 전자 편향(electromagnetic deflection)이라고 불린다. 두 경우 모두 비트를 전압으로 변환해야 하기 때문에 디스플레이도 D/A 회로를 활용하는 또 다른 예라 할 수 있다.

  오늘날 CRT는 대부분 액정 디스플레이(LCD : Liquid Crystal Display)로 대치되고 유물로 남아있다. 액정(액체 결정)은 전기를 가하면 빛을 통과시키는 성질이 바뀌는 물질이다. 정형적인 평판(flat screen) 디스플레이는 화면의 각 점마다 R,G,B와 필터 뒤에서 빛을 비춰주는 광원으로 구성된다는 점에서 CRT와 비슷하다. LCD로 인해 핸드폰, 랩탑, 평면 TV 등이 가능해졌다.

  초기 화면 기반 터미널은 텍스트만 표시할 수 있었기 때문에 글래스 tty(glass tty)라고 불렸다. 이런 터미널은 보통 80문자로 이뤄진 텍스트를 24줄 즉 1920문자를 표시할 수 있었다. 한 문자가 1바이트 였기 때문에 이는 2KiB보다 작은 메모리르 차지했고, 당시에도 이 정도 메모리는 감당가능했다. 시간이 지남에 따라 화면 편집이나 커서 움직임등의 더 많은 기능이 추가됐고 이런 기능은 ANSI X3.64로 표준화 됐다.

* 벡터 그래픽

  CRT는 그래프를 그릴 수 있는 모눈종이처럼 작동한다. 전자 광선은 x축 전압과 y축 전압에 따라 어떤 지점으로 이동한다. 그리고 z축 전압으로 밝기를 정할수 있다. 원래 CRT는 색을 지원하지 않았기 때문에 흑백이나 그레이스케일(grayscale) 디스플레이였다. 인치당 표시할 수 있는 좌표 위치 개수가 해상도(resolution)이다.

  벡터 그래픽(vector graphic)은 선 또는 벡터(vector)로 그림을 그리는 방식이다. 벡터 그래픽은 선을 그려서 그림을 만들어낸다. 그림은 디스플레이 목록(display list)에 의해 그려진다. 이 목록은 그림을 그리는 명령어로 이러진 목록이다.

  ```
  1. (2,0)으로 이동
  2. (1,1)으로 이동
  3. (0.0)으로 이동
  4. 1단계 부터 다시 시작
  ```

  마지막 명령어의 존재 이유는 화면 상의 이미지가 아주 빠르게 사라지기 때문에 처음부터 그림을 다시 그려야 한다. 이런 방법으로 그림을 표현할 수 있는 이유는 CRT 인광물질의 지속성(persistence) 때문이다. 지속성은 전자 빔이 사라진 다음 얼마 동안 인광물질이 빛을 발생시키는가를 뜻하며, 사람의 눈은 응답 시간이 더 느리기 때문에 그림을 반복해 그리면 화면에 이미지가 표시된 상태를 유지할 수 있다.

  이 목록에는 다른 요소도 있다. 미국의 교류(alternating current) 전원 주파수가 60Hz이기 때문에 우리 주변에는 60Hz 방사파가 아주 많다. 방사파를 막기 위한 최선에 노력에도 불구하고 이런 방사파가 디스플레이에 영향을 끼쳐서 그림이 흔들릴 수 있다. 그래서 벨 연구소에서 개발된 글랜스 G(GLANCE G)같은 그래픽 터미널에는 '전원 전압이 음에서 양의 방향으로 0볼트를 지나간 다음에 1단계를 다시 시작하라'와 같은 명령어가 있다. 이런 명령어를 쓰면 글미이 방해전파와 동기화돼서 항상 똑같은 시점에 흔들리므로 흔들림을 덜 인식하게 된다.

  이미지를 그리려면 시간이 걸린다. 이로 인한 부작용으로 디스플레이 목록이 아주 길어지면 초당 60번 화면을 다시 그릴수 없다는 단점이 있다. 화면을 다시 그리는 속도가 초당 열 몇 번 수준으로 떨어지면 화면이 아주 깜빡거린다.(플리커 flicker 현상)

  텍트로닉스(Tektronix)라는 회사는 이런 깜빡거림에 대해 스토리지 튜브(storage tube)라는 흥미로운 해결법을 내놨다. 스토리지 튜브에 아주 복잡한 이미지를 그릴 수 있지만 그림을 지우려면 화면을 흔들어야 한다. 글랜스 G에서는 벡터 수가 많아짐에 따라 플리커가 발생하기 때문에 속이 꽉 찬 이미지를 그리기가 힘들었다. 스토리지 튜브에서는 벡터 개수 제한이 없기 때문에 원하는 이런 이미지를 그릴 수 있지만 중심부가 어두워지는 경향이 있다. 글랜스 G에서는 디스플레이 목록에서 선을 없애면 화면에서도 선이 사라지지만, 스토리지 튜브에서는 화면을 지우지 않고서는 불가능하다. 화면을 지울 때는 밝은 녹색으로 화면이 깜빡 거리기 때문에 나이 많은 프로그래머의 눈을 따갑게 만들곤 했다.

* 레스터 그래픽

  레스터 그래픽(raster graphics)은 점으로 이뤄진 그래픽으로 벡터 그래픽과 완전히 다른 접근 방법이다. 원래 텔레비전이 작동하는 방식이 레스터 방식이다. 레스터는 연속적인 그림 패턴을 말한다.

  레스터는 왼쪽 위에서 출발해 화면을 지난다. 그 후 수평 리트레이스(horizontal retrace)를 통해 다시 화면 왼쪽 다음 줄 위치로 이동한다. 마지막 줄을 그린 다음에는 수직 리트레이스(vertical retrace)를 통해 그리기를 시작했던 왼쪽 위로 다시 이동한다.

  래스터가 달리고 있는 동안에 우리가 해야 할 일은 원하는 이미지를 표시하기 위해 정확한 시간에 밝기를 정확히 변화시키는 것뿐이다. 

  래스터 디스플레이는 '실제' 화면이다. 이말은 점과 점 사이에는 그림을 그릴 수 없다는 뜻이다. 이로 인해 사선이 이상해 보이는 등 불쾌한 시각적 아티팩트가 생긴다. 전형적인 래스터 디스플레이의 해상도가 꽤 낮기 때문에(보통 인치당 100개의 점) 생기는 현상이다. 해상도가 낮아서 디지털 이미지에서 설명한 내용과 비슷하게 언더샘플링과 에일리어싱이 발생한다. 이제는 컴퓨터 계산 능력이 충분하기 때문에 슈퍼샘플링과 같은 기법을 활용한 안티 에일리어싱(anti aliasing)을 흔히 적용한다.

  래스터 스캔을 팩스, 레이저 프린터, 스캐너 등에도 사용한다. 

  래스터 디스플레이는 디스플레이 목록을 사용하지 않짐나 래스터 디스플레이 뒤에서는 여전히 디스플레이 목록이 쓰인다. 웹 페이지 역시 디스플레이 목록이다. 오픈GL(OpenGL) 그래픽 언어에도 디스플레이 목록이 들어가며, 그래픽 하드웨어 중에는 이 그래픽 언어를 지원하는 경우가 종종 있다. 모노크롬(monochrome) 디스플레이는 래스터의 각 위치를 1비트로 표현하는 메모리를 사용한다. 과거에는 큰 메모리 였으나 이젠 메모리는 큰 문제가 되지 않는다. 물론 래스터 디스플레이의 이미지를 표현하는 메모리는 아주 빨라야 한다. 회색의 밝기를 256단계로 표현할 수 있는 래스터 디스플레이라면 각 래스터 지점마다 8비트가 필요하다.

  색깔은 빠르게 화면에 도입됐다. 모노크롬이나 그레이스케일 디스플레이는 만들기 쉽다. 화면 내부를 층으로 돞기만 하면된다. 색을 표현할수 있는 컬러 디스플레이는 래스터의 각 지점마다 세 가지 색의 점을 표현할 수 있어야 하고 3개의 전자빔을 세 점의 정밀하게 맞출 수도 있어야 한다. 따라서 전형적인 디스플레이의 경우 디스플레이 메모리도 3배가 필요하다.

* 키보드와 마우스

  터미널은 데이터를 출력하는 역할을 할 뿐만아니라 입력하는 데이터를 받아들이기도 한다. 키보드와 마우스, 터치패드는 데이터 입력을 담당한다.

  키보드는 아주 쉽다. 키보드는 단지 여러 스위치와 논리 회로를 묶은 것 뿐이다. 일반적으로 키보드를 만드는 방법은 키 스위치들을 격자상에 두고 멀티플렉싱하는 것이다. 전원을 격자의 각 행에 순차적으로 인가하고 각 열의 입력을 읽는다.

  현재 사용하는 마우스는 스탠퍼드 연구소에서 근무하던 미국 엔지니어 더글러스 엥겔바트에 의해 발명됐다. x좌표과 y좌표를 담당하는 2개의 쿼드러처 인코더를 사용하면 마우스를 만들 수 있다.

  터치패드나 터치스크린 기술도 많이 사용한다. 터치스크린은 투명해야 화면을 볼 수 있지만 터치패드는 투명하지 않아도 된다는 점이다. 터치 장치는 키보드와 비슷하게 행 스캐닝과 열 스캐닝을 하되, 훨씬 더 미세한 단위로 스캔하는 장치다.





### 정리

6장에서는 프로세서가 I/O를 효율적으로 처리하게 해주는 인터럽트 시스템에 대해 배웠고 여러 I/O 장치의 동작과 각 장치가 컴퓨터와 어떻게 상호작용하는 지도 배웠다. 그리고 아날로그 데이터를 디지털 컴퓨터에서 처리하기 위해 샘플링하는 방법을 자세히 살펴봤다. 지금까지 컴퓨터가 어떻게 작동하는 지 충분히 배웠고 이제 하드웨어와 소프트웨어 사이 관계를 살펴보면서 하드웨어 상에서 잘 작동하는 소프트웨어를 작동하는 방법을 배운다.
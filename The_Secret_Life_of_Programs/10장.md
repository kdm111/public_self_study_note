## 애플리케이션 프로그래밍과 시스템 프로그래밍

> 고수준 언어와 저수준 언어 프로그래밍 방식 비교



브라우저는 복잡한 애플리케이션 프로그램으로 아주 고차원의 '명령어'를 제공하는 '컴퓨터'를 구현한 것이다. 이번 장에서는 브라우저를 실행하는 프로그램을 작성한 다음에 비슷한 프로그램을 브라우저를 사용하지 않고 실행한다.

```
두 프로그램 시나리오

프로그램 #1(애플리케이션 수준)		프로그램 #2(시스템 수준)
브라우저(시스템 수준) 
                       운영 체제
                       I/O 장치
```

운영체제는 사용자 프로그램이 I/O 장치의 복잡도를 상당 부분 볼 수 없게 가려준다. 비슷하게 브라우저 같은 사용자 프로그램은 다른 애플리케이션 프로그램이 운영체제를 다루는 볼 수 없게 가려준다. 시스템 프로그래머가 되려면 이런 내용은 알 필요가 있다.





### HTML과 JS

HTML은 브라우저에서 실행되는 DOM 트리이다. JS는 HTML의 요소들을 브라우저 콘솔에서 접근하며 프로그래밍을 하게된다. CSS는 클래스를 지정하면서 인라인 스타일을 사용하며 스타일링을 한다.





### C 프로그램

브라우저는 고수준 가상 머신이다. 가상 머신의 모든 기능은 소프트웨어로 구현되었다. 이로 인해 중요한 부분을 감추면서 쉽고 빠르게 프로그램을 작성할 수 있다. 하지만 C는 그렇게 하지 못한다.



* 터미널과 명령줄

  이전에는 터미널이 컴퓨터 밖에 있는 하드웨어 였지만 이제는 소프트웨어로 구현된다. 컴퓨터에서 터미널을 열면 명령 프롬프트(command prompt)를 볼 수 있다. 명령 프롬프트 다음에 문자를 타이핑하면 터미널이 응답한다.

* 프로그램 빌드

  C는 컴파일 언어이기 때문에 자바스크립트를 인터프리터로 실행했던 것처럼 소스코드를 실행할 수는 없다. 소스 코드를 먼저 기계어로 변환해야 한다. 명령줄에서 쉽게 이런 변환은 할 수 있다. 명령을 터미널에서 타이핑해서 기계어로 만든다.(이를 빌드한다고 부른다.)

  ```
  프로그램 빌드하기
  
  cc program.c -o program
  cc : c 컴파일러
  program.c : 소스 파일 이름
  -o : 출력 파일 옵션
  program : 프로그램 이름
  ```

  출력 파일이 있으면 보통 터미널에 이 출력 파일의 이름을 타이핑하면 파일을 실행할 수 있다.

* 터미널과 장치 드라이버

  터미널은 I/O 장치이며, 사용자 프로그램은 직접 I/O 장치와 통신하지 않는다. 운영체제가 중간에서 통신을 중재한다.

  ```
  I/O 장치 중재
                                 | 시스템 콜
  터미널 <-> 장치 드라이버 | 운영체제 < | > 사용자 프로그램
  ```

  터미널이 별도의 장치였을 때로 돌아가면, 컴퓨터와 터미널은 RS-232 직렬 연결로 연결됐었다. 터미널과 컴퓨터를 연결하는 선이 물리적으로 존재했다. 오늘날 운영체제는 이런 연결이 존재하는 것처럼 소프트웨어로 흉내 내어 동작한다. 그래서 레거시(legacy) 프로그램을 변경하지 않고 그대로 요즘에도 사용할 수 있다.

* 문맥 전환

  장치 드라이버는 보기보다 복잡하다. 복잡한 주된 이유는 운영체제가 한 번에 사용자 프로그램을 하나 이상 실행할 수 있기 때문이다. 컴퓨터는 레지스터 집합이 하나 뿐이므로 운영체제는 한 사용자 프로그램을 다른 사용자 프로그램으로 바꿀 때마다 레지스터들을 저장하고 복구 해야 한다. CPU 레지스터 외에도 저장하고 복구해야 할 내용이 많다. 예를 들어, MMU 레지스터나 I/O 상태 등도 저장하고 복구해야 한다. 이때 저장하고 복구해야 하는 모든 내용을 프로세스 문맥(process context)라고 부르거나 그냥 문맥이라고 부른다. 문맥의 크기가 커서 문맥 전환(context switching) 비용이 비싸기 때문에 문맥 전환을 경솔히 많이 하려 하지 않는다.

  ```
  문맥 전환
  
                           사용자 프로그램
     | --------------------------------------------    |
     |					   운영 체제                   |
  문맥 저장 -> 요청을 처리할 수 있는가? -(y)> 요청을 만족시킴 -> 문맥 복원
                    |(n)
             사용자 프로그램 일시 중단 -> 준비 상태인 프로그램 찾기 -> 프로그램 깨우기 -> 요청을 만족시킴
                 (슬립 시키기)
  ```

  때때로 OS는 사용자 프로그램을 슬립(sleep)시킨다. 심지어 요청을 만족시킬 수 있는 경우에도 때로 다른 사용자 프로그램이 실행될 기회를 주기 위해 현재 실행 중인 사용자 프로그램을 슬립시킬 수도 있다.

  사용자가 키를 누를 때마다 문맥 전환이 일어나는 것을 바라지는 않는다. 이런 경우 문맥 전환 횟수를 최소화하기 위해 사용자가 `enter`를 누르기 전까지는 사용자가 무엇을 타이핑하기 전까지는 상관이 없다. 사용자 프로그램을 시스템 콜을 사용해 터미널에서 입력을 '읽고' 싶다는 의사를 표시한다. (키 입력이 없기 때문에) 대기하는 것 외에는 할 일이 없어서, 사용자 프로그램은 슬립 상태가 된다. 그 결과 OS는 또 다른 프로그램을 실행하는 등의 다른 동작을 수행할 수 있다. 그 결과 OS는 또 다른 프로그램을 실행하는 등의 다른 동작을 수행할 수 있다. 물리적 장치와 관련한 처리를 담당하는 장치 드라이버(device driver)는 터미널에서 들어오는 문자를 버퍼(buffer)에 저장하고, 사용자가 키를 누를 때가 아니라 `enter`를 누를 때만 프로그램을 깨운다.

  버퍼는 소프트웨어 영역에서 버퍼는 FIFO(First In First Out) 데이터 구조다.(하드웨어 영역의 버퍼는 연약한 구성요소를 보호하기 위해 사용하는 회로를 뜻하는 경우가 더 많다.) FIFO는 다른 말로 큐라고 하며 큐 역시 스택과 마찬가지로 공간을 다 쓰면 오버플로가 일어나고, 빈 큐에서 원소를 꺼내려고 시도하면 언더 플로가 일어난다.

  ```
  input -> 3 2 1 0 -> output
  ```

  터미널에서 키보드와 디스플레이 사이에는 직접적 연결이 없다. 키보드는 컴퓨터에 데이터를 보내고 디스플레이는 컴퓨터에서 데이터를 받는다. 원래는 키보드와 디스플레이를 위한 선이 따로 있었지만 저니중 모드를 사용하면 선 하나로 양방향 통신을 동시에 진행할 수 있다. 사용자가 누른 키가 무엇인지 혼동할 수도 있으므로 키 입력에 대한 버퍼를 사용하는 것만으로는 충분하지 않고, 사용자 입력을 즉시 화면에 표시하는 에코(echo)가 필요하다. 그리고 사용자 키 입력은 프로그램이 디스플레이에 보내는 출력보다 느리기 때문에 입력 버퍼(input buffer)와 출력 버퍼(output buffer)가 필요하다. 출력 버퍼가 찾는 데도 프로그램이 터미널에 출력을 시도하면 프로그램을 슬립 상태로 전환한다. 입력 버퍼가 찬 경우에는 드라이버가 사용자에게 화면을 깜빡이거나 삐 소리를 울리는 등의 피드백을 제공할 수 있다.

  ```
  터미널 장치 드라이버의 버퍼링과 에코
  
                 장치 드라이버
  		->		입력 버퍼           ->
  터미널						(에코)|
  		<-      출력 버퍼           <-
  ```

  실제 장치 드라이버는 더 복잡하다. 드라이버 설정을 변경하기 위해 추가된 시스템 콜도 있다. 에코를 끄거나 켤 수 있고, 버퍼링을 켜거나 끌 수 있고, 버퍼링이 꺼져 있는 경우를 로 모드(raw mode)라고 부르고, 버퍼링이 켜저 있는 모드를 쿡드 모드(cooked mode)라고 부른다. 사용자 프로그램을 깨우는 프로그램이나 문자를 지우는 키(backspace or delete)를 지정할 수도 있다.

* 표준 I/O

  장치 드라이버 내의 버퍼링은 문제 중 일부만 해결해준다. 사용자 프로그램에도 비슷한 문제가 있다. 장치 드라이버가 입력을 버퍼링해도 사용자 프로그램이 사용자가 문자를 입력할 때마다 시스템 콜을 호출하면 장치 드라이버 쪽 입력 버퍼는 쓸모가 없다. 마찬가지로 사용자 프로그램이 문자를 기록하기 위해 매번 시스템 콜을 호출하면 장치 드라이버에 출력 버퍼가 아무 역할도 못한다. 이런 상황이 자주 있기 때문에 표준 입력/출력(standard input/output) 라이브러리(stdio)가 만들어 졌다. 표준 입출력 라이브러리에는 사용자 프로그램이 쓸 수 있는 버퍼 I/O 함수가 들어있다.

  stdio 라이브러리는 버퍼 입력을 지원한다. 버퍼 입력을 사용하면 시스템 콜을 한 번만 사용해 장치 드라이버에서 읽은 데이터를 버퍼에 넣을 수 있다. 사용자 프로그램은 버퍼가 빌 때까지 버퍼에서 입력 문자를 얻는다. 버퍼가 소진되면 다시 시스템 콜을 통해 입력을 더 가져온다. 출력하는 경우에는 버퍼가 차거나 중요한 문자('\n')가 출력될 때까지 문자가 버퍼에 들어간다. 

  ```
  stdio 버퍼를 사용하는 사용자 프로그램
  
            운영체제              사용자 프로그램
          장치 드라이버               stdio
       ->   입력 버퍼               출력 버퍼  ->
  터미널                                      사용자 코드
       <-   출력 버퍼               입력 버퍼  <-
                       시스템 콜
  ```

  입출력을 효율적으로 하기 위해 아주 많은 일을 하는 것처럼 보이지만 이게 끝은 아니다. 사용자 프로그램을 터미널 장치 드라이버와 연결해야 한다.

  운영체제의 open 시스템 콜은 파일 이름을 파일을 참조할 수 있는 핸들(handle)이나 파일 디스크립터(file descriptor)로 바꿔준다. 이 핸들을 close 시스템 콜로 닫으면 더 이상 핸들을 사용할 수 없다. 핸들은 마치 공연이나 박물관에 들어가면서 가방을 맡기고 받는 보관증과 비슷하다. stdio 라이브러리는 open 및 close와 애등되는 fopen과 fclose라는 함수를 제공한다. 이 두 함수는 open과 close 시스템 콜을 사용하되, 파일을 열어서 핸들을 얻을 때 버퍼를 설정하고 파일 핸들을 닫을 때 버퍼를 해제해준다. 유닉스는 장치를 파일처럼 추상화 해주므로 `/dev/tty`등의 특별한 파일을 열면 터미널 장치에 접근할 수 있다.

* 원형 버퍼

  stdio의 버퍼는 큐와 비슷하게 보이지만 실제 규현은 그렇지 않다.

  큐에서 새로 값을 추가할 위치를 알기 위해 줄의 맨 끝을 추적해야 한다.

  큐에서 팝이 일어날 경우 데이터는 한 칸씩 앞으로 땅겨지며 이런 일이 큐에 있는 모든 원소에 대해 발생한다. 큐가 원을 만들어서 데이터의 이동을 막을 수 있다.

  큐의 인큐와 디큐과정에서 인덱스를 조절하면서 구현이 가능하다.

  ```python
  class queue():
      def __init__(self):
          self.arr = [None] * 10;
          self.inputIdx = 0;
          self.outputIdx = 9
      def enqueue(self, val):
          self.arr[inputIdx] = val
          inputIdx += 1
          inputIdx %= 10
      def dequeue(self):
          val = self.arr[outputIdx]
          self.arr[outputIdx] = None
          outputIdx += 1
          outputIdx %= 10
          return val
  ```

* 추상화를 활용한 코드 개선

  추상화의 경우 자바스크립트에 추가하기는 어렵다.

  ```
  브라우저의 인터페이스      운영체제의 인터페이스
  
         게임
  |(입력)     |(파일)
        브라우저             게임
          |                 |
        운영체제            운영체제
  |(장치)     |(파일)     |(장치) |(파일)
  ```

  운영체제는 파일과 장치에 대해 똑같은 인터페이스를 제공한다는 사실을 알 수 있다. 이 인터페이스를 왼쪽의 브라우저나 오른쪽의 C 버전이 모두 사용한다. C 프로그램은 브라우저 처럼 파일에서 입력을 받는 코드를 장치에서 입력을 받는 부분에 쓸 수 있다는 뜻이다. 하지만 브라우저는 추상화를 자바스크립트를 통해 프로그래머에게 넘기지 않는다. 대신 완전히 다른 인터페이스의 완전히 다른 코드를 사용해 새 기능을 추가해야 한다. 인터페이스 선택은 프로그래밍의 편의와 결과의 명확성에 큰 영향을 끼친다.

* 런타임 라이브러리와 표준 입출력

  C프로그램을 실행하려면 우리가 작성한 코드를 컴파일 한다음 컴파일된 코드와 이 코드가 사용하는 `stdio` 라이브러리 등의 다른 코드를 링크(link)해야 한다. 런타임 라이브러리도 포함시켜야 한다. C에서 런타임 라이브러리는 `crt0`등의 이름으로 불린다. 런타임 라이브러리는 스택과 힙을 설정해서 사용할 수 있도록 준비하는 등의 설정을 담당한다. 런타임 라이브러리를 추가로 터미널 장치 드라이버와 연관된 파일을 하나는 입력을 위해, 다른 하나는 출력을 위해 연다.

  `stdio` 라이브러리는 런타임 라이브러리가 연 시스템 파일 디스크립터를 파일 포인터(file pointer)와 연관시킨다. 파일 포인터는 버퍼링이나 파일 관리에 필요한 데이터 구조를 가리킨다. `stdio`는 기본적으로 세 가지 파일 포인터를 제공한다. `stdin`은 표준 입력, `stdout`은 표준 출력, `stderr`는 표준 에러 출력을 가리킨다. `stdout`과 `stderr`는 똑같은 대상으로 데이터를 보내지만 `stderr`는 버퍼를 사용하지 않고 `stdout`은 버퍼를 사용한다. 오류 메시지를 `stdout`으로 보내면 메시지가 버퍼에 들어가기 때문에 프로그램이 중단될 때 표시되지 않을 수도 있다. `stdout`과 `stderr`는 파일 디스크립터를 공유한다.

  ```
  stdin stdout stderr 파일 포인터
                               사용자 프로그램
          파일 디스크립터 0 ->   |        | -> stdin
  운영 체제                     
          파일 디스크립터 1 <-   |        | <- stdout
                         | <- stderr
  ```

* 버퍼 오버플로

  `stdio`에서 버퍼 오버플로(buffer overflow)라는 아주 심각한 시스템 프로그래밍 오류가 있다. `stdio`가 원래 만들어졌을 때는 `stdin`에서 사용자가 새줄 입력을 입력할 때까지 받은 입력을 사용자가 제공한 버퍼로 전송하는 `gets`라는 함수가 있다. `y,n,q` 등의 응답을 받기 위해 이 함수를 사용할 수 있다. `buffer`에는 한 글자와 문자열 끝을 표현하는 `NULL` 문자가 들어갈 공간이 있다.
  
  ```c
  gets로 입력 읽기
  
  char  buffer[2];
  gets(buffer);
  ```
  
  `gets`는 입력이 버퍼 끝을 벗어나지 않는지 검사하지 않기 때문에 문제다. 메모리 상에서 변수가 buffer 바로 뒤에 할당 됐다고 가정하자.
  
  ```
  메모리 버퍼 오버플로
  
    메모리
  buffer[0]
  buffer[1]
  variable
  ```
  
  어떤 유저가 입력 `yyy`를 변수에 `y`를 넣을 수 있다는 사실을 알아낼 수 있다. 사실상 변수는 존재하지 않는 `buffer[2]`와 같다. 이로 인해 나쁜 일이 발생할 수 있다. 발견된 보안 문제중 상당 수는 이런 종류의 오버플로 버그로 발생한 문제다. 이 문제는 `stdio`에 버퍼 경계를 조사하는 `fgets`를 추가해 수정됐다. 하지만 버퍼 오버플로 버그가 일어날 수 있는 상황이 아주 많다. 결코 버퍼 크기가 충분히 크다고 가정하지 마라





### 정리

고수준 애플리케이션은 여러가지 소소한 세부 사항을 중간 소프트웨어가 자동으로 처리해주기 때문이다. 하지만 일관성 있는 인터페이스를 제공하지 않는 환경에서는 더 구현하기 힘들다.

더 나아가 간단한 애플리케이션을 작성하기 위해 아주 복잡한 애플리케이션 환경을 사용하면 버그가 발생할 확률이 높아진다. 버그 확률은 애플리케이션 코드와 그 코드가 실행될 환경을 합한 크기가 커짐에 따라 더 높아진다. 브라우저가 점점 느리게 작용하거나, 브라우저를 다시 시작해야 했던 경험을 경험해 보면 알 수 있다.

시스템 프로그래밍 쪽이 문자열 관리, 메모리 관리, 버퍼 관리 등 훨씬 더 신경 써야 할 세부 사항이 많다는 사실을 알았을 것이다. 하지만 간결하고 안전한 코드가 목표라면 이런 세부사항이 더 중요하다. 
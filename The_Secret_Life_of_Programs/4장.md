# 컴퓨터 내부 구조 : 컴퓨터 하드웨어는 어떻게 구성되는가



전자 부품을 다양하게 조합해 비트를 조작하는 회로를 만들 수 있는 데 이런 회로를 컴퓨터(computer)라고 부른다. 

컴퓨터를 만드는 데에는 다양한 방법이 있다. 이번 장에서 선택한 설계는 설명이 쉬운 설계여서 그렇지 더 나은 설계라서 선택된 것은 아니다. 컴퓨터가 작동하기 위해서는 많은 복잡한 구조가 필요하다. 

현대적 컴퓨터는 크게 메모리(memory), 입력과 출력 (I/O input & output), cpu(central processing unit)라는 세 가지 부분으로 나눌 수 있다. 





### 메모리

컴퓨터에는 조작할 비트를 저장할 장소가 필요하다. 이런 장소를 메모리라고 부르며 컴퓨터가 메모리를 어떻게 사용할까?

메모리는 집이 빈틈없이 늘어선 거리와 같다. 모든 집은 크기가 같고 같은 비트만 저장할 수 있다. 컴퓨터를 만드는 규칙에는 각 집마낟 1바이트를 저장한다고 되어있다. 각 집에는 주소(address)가 부여된다. 컴퓨터 메모리가 64 MiB라면 전체는 64 * 1024 * 1024 바이트이다. 각 바이트에는 0부터 67,108,863까지 주소가 붙어 있다. 컴퓨터에서는 이런 주소가 의미가 있다.

구체적인 주소에 있는 메모리를 가르킬 때 메모리 위치(memory location)라는 말을 자주 사용한다.

메모리의 기본 단위가 바이트라는 것이 꼭 바이트 단위로만 데이터를 읽어야 한다는 뜻은 아니다. 32비트 컴퓨터는 메모리를 4바이트 덩어리로 64비트 컴퓨터는 8바이트 덩어리로 구성한다. 이런 구성이 중요한 이유는 4차선과 8차선 고속도로를 사용하는 것과 비슷하다. 차선이 더 많으면 더 많은 데이터를 버스에 실을 수 있기 때문에 더 많은 양의 데이터를 처리할 수 있다. 메모리를 주소로 지정할 때 어떤 대상(1바이트, 4바이트, 8바이트)을 원하는 지 지정해야 한다. 32비트 컴퓨터에서는 4바이트를, 64비트 컴퓨터는 8바이트를 사용하기 때문에 긴 워드의 주소를 지정하는 방법은 1바이트의 주소를 지정하는 방식과는 다르다. 긴 워드 하나의 주소에는 4개의 바이트 주소에 해당하는 데이터가 들어있다.

또 다른 관점으로 32비트 컴퓨터의 메모리 주소를 포플렉스(fourplex : 집이 연달아 4개 붙어있는 땅콩집)각 포플렉스에는 듀플렉스가 2개 들어있고 각 듀플렉스에는 유닛이 2개 들어있다. 이 말은 각 유닛이나 듀플렉스 도는 포플렉스의 주소를 지정할 수 있다는 뜻이다.

각 건물과 고속도로가 연결될 때 바이트마다 각기 다른 차선을 배정받고 긴 워드는 고속도로 전체를 사용한다는 사실을 확인하라. 도심을 오가는 비트들은 좌석이 4개인 네 차선에 걸친 버스를 통해 오가며, 버스 좌석은 차선마다 하나씩이다. 현대적 컴퓨터에서 이 버스는 오직 한 건물(포플렉스)에만 정차해 비트를 태워서 도심으로 돌아온다. 이 말은 건물을 여러개 차지하고 있는 비트를 한 번에 사용할 수 없다는 뜻이다. 최소 두 번은 왕복해야 한다는 것이다.

한 번에 두 건물에 걸쳐있는 데이터를 읽는 경우를 정렬이 맞지 않는 접근(nonaligned access)라고 부른다. 

다양한 메모리가 존재한다. 각 메모리는 서로 가격/성능 비율(price/performance ratio)가 다르다. 예를들어 SRAM은 굉장히 빠르고 비싸지만 디스크는 저렴하지만 느리다.

도심을 오가는 버스의 각 자리에는 누가 앉을까? 긴 단어의 경우 가장 왼쪽 자리에 0번 바이트가 들어갈까 3번 바이트가 들어갈까? 이는 사용하는 프로세서에 따라 달라진다. 두 방식이 모두 사용되기 때문에 실제로 엔디안(endian)이라는 용어는dlfjs ckdlfmf vygusgksek.

인텔 같은 경우 0번 바이트가 가장 오른쪽에 간다. 모토로라 프로세서 같은 경우에는 0번 바이트가 가장 왼쪽에 간다.

```
리틀 엔디안(인텔)	 : 3 2 1 0
빅 엔디안(모토로라)	 : 0 1 2 3
```

한 시스템에서 다른 시스템으로 데이터를 전송할 때는 엔디안을 염두에 두어야 한다. 엔디안을 무시하면 데이터 순서가 뒤섞일 수 있다. 유닉스 운영체제를 PDP-11에서 IBM 시리즈 1로 포팅할 때 이런일 이 발생했다. 어떤 프로그램이 'Unix'를 출력해야 하는데 16비트 워드 내에서 바이트 순서가 뒤바뀌면서 'nUxi'를 출력했다. 이 사건으로 인해 눅시 신드롬(nuxi syndrome)이라고 부르기도 한다.





### 입력과 출력

외부 세계와 통신하지 않는 컴퓨터는 필요가 없을 것이다. 컴퓨터에 정보를 전달하거나 정보를 가져올 방법이 필요하다. 입력/출력(input / output)을 줄여서 I/O라고 부른다. I/O에 연결되는 장치를 I/O 장치(I/O device)라고 부른다. 이들은 컴퓨터 주변부에 위치하기 때문에 주변장치(peripheral device)라고 부르며 영어로는 퍼리퍼럴(peripheral)이라고 부른다.

컴퓨터에는 I/O 처리를 위한 별도의 버스가 필요하다. I/O 버스도 메모리 버스와 비슷하다. 컴퓨터가 물리적으로 큰 과거에는 전기적 연결이 한정된 작은 패키지에 모든 것을 욱여넣기 힘들었기 때문에 I/O 버스를 메모리 버스와 분리하는 것이 타당했다. 그리고 메모리가 많지 않았기 때문에 제한된 주소를 I/O를 지원하느라고 낭비하는 일은 바람직 하지 않았다.

```
I/O 버스 <-> 도심 <-> 메모리 버스
```

지금은 32비트나 64비트 컴퓨터가 흔해져 메모리 거리의 주소 수가 훨씬 많아졌다. 메모리 거리가 너무 길기 때문에 모든 주소에 메모리가 존재하지 않게되었고 그에 따라 빈 주소가 많아졌다. 다시 말해 아무 메모리도 연관되지 않은 주소가 많아졌다. 이제는 메모리 거리 중 일부를 I/O 장치에 할당하는 것이 더 타당해졌다. 이제 더 많은 부분을 연결이 한정적인 패키지에 구겨 넣어야 하기 때문에 I/O와 메모리가 같은 버스를 사용하는 것이 타당하다.

많은 컴퓨터에는 설계상 표준 입력/출력 슬롯이 있어서 일관된 방식으로 I/O 장치를 연결할 수 있다. 아무도 사용하지 않는 주소 영역을 몇몇 사용 허가된 지역으로 나눈다. 각 슬롯을 차지한 장치는 자신에게 할당된 주소를 모두 사용할 수 있다. 각 슬롯에는 각 슬롯에 어떤 장치가 연결됐는지 파악할 때 사용할 수 있는 특별 주소가 있다.

```
	메모리 I/O I/O I/O
도심 <------버스 경로------->
```





### 중앙 처리 장치

중앙 처리 장치(Central Processing Unit : CPU)는 실제 계산을 처리하는 컴퓨터 부품이다. 우리가 사용하는 비유에서 도심은 CPU에 해당한다. 다른 모든 요소는 CPU를 지원하는 역할을 한다. CPU는 다양한 요소로 이뤄진다.



*산술 논리 장치*

산술 논리 장치(ALU : arithmetic logic unit)는 CPU의 핵심 부품이다. ALU는 산술 계산, 불리언 대수 및 기타 연산을 수행하는 방법을 알고 있는 장치이다ㅏ.

```
피연산자 A ->	  -> 결과
			ALU
피연산자 B ->	  -> 조건 코드
			^
			|
		 연산 코드
```

피연산자(operand)는 수를 표현하는 비트일 뿐이다. 연산 코드(operation code) 즉 명령 코드(opcode)는 피연산자에 대해 ALU가 어떤 연산자(operator)를 적용할 지 지정한다. 결과(result)는 물론 피연산자에 연산자들을 적용한 결과를 뜻한다.

조건 코드(condition code)에는 결과에 대한 추가 정보가 들어간다. 보통 조건 코드 레지스터(condition code register)라는 레지스터에 조건 코드가 저장된다. 3장에서 배운 것 처럼 레지스터는 메모리 거리가 아닌 다른 곳에 존재하는 메모리일 뿐이다. 레지스터는  메모리 거리가 아닌 다른 곳에 존재하는 메모리일 뿐이다. 레지스터는 특별히 비싼 메모리이기 때문에 할 수 있다. 전형적인 조컨 코드 레지스터는 다음과 같다.

```
7 6 5 4 3 2 1 0
          N Z O : 음수, 영, 오버플로
```

위의 숫자는 비트 번호이고 비트 번호를 사용해 비트를 편리하게 가리킬 수 있다. 비트 중 일부를 사용하지 않는다.

N 비트는 마지막으로 수행할 연산 결과가 음수인 경우 1로 설정된다. Z 비트는 연산 결과가 0일 경우 1로 설정된다. O 비트는 연산에서 오버플로나 언더플로가 생긴경우 1이된다.

예제 ALU 명령코드

```
명령코드 니모닉(mnemonic) 설명
0000 : clr : 피연산자는 무시하고 결과의 모든 비트를 0으로 만든다.
0001 : set : 피연산자는 무시하고 결과의 모든 비트를 1로 만든다.
0010 : not : B는 무시하고 A의 비트 중 1은 0으로 0은 1로 만든 값을 결과로 한다.
0011 : neg : B는 무시하고 A의 2의 보수인 -A가 결과다.
0100 : shl : A를 B의 하위 4비트값(0~16)만큼 왼쪽으로 shift한다.
0101 : shr : A를 B의 하위 4비트값(0~16)만큼 오른쪽으로 shift한다.
0110 : 미사용
0111 : 미사용
1000 : load : 피연산자 B의 값을 결과로 보낸다.
1001 : and : A and B가 결과다
1010 : or : A or B가 결과다.
1011 : xor : A xor B가 결과다.
1100 : add : A + B가 결과다
1101 : sub : A - B가 결과다.
1110 : cmp : B - A를 계산해서 조건 코드를 설정한다.
1111 : 미사용
```

ALU는 셀렉터와 논리 게이트를 연결한 것이다. 일반적인 ALU 설계는 다음과 같다.

```
0 - clr
1 - set
!A - not        ALU => 결과
B - load        
A&B - and
A|B - or
명령코드
```



*시프트*

왼쪽 시프트는 어떤 숫자의 모든 비트를 왼쪽으로 1비트씩 옮기고 맨 왼쪽 비트는 버리고 비게 되는 가장 오른쪽 비트에 0을 넣는다. 예를 들어 0010을 시프트 하면 0100이 된다. 어떤 수를 1비트 왼쪽으로 시프트하면 그 수에 2를 곱한 것과 같기 때문에 왼쪽 시프트는 아주 편리하다.

오른쪽 시프트는 어떤 숫자의 모든 비트를 오른쪽으로 1비트씩 옮기고 맨 오른쪽 비트는 버리고 비게되는 왼쪽 비트에 0을 넣는다. 0100을 시프트하면 0010을 얻는다. 이런 식으로 오른쪽으로 시프트하면 2로 나누면서 나머지를 버린 것과 같다.

왼족 시프트를 할 때 사라지는 MSB 값이나 오른쪽 시프트를 하면 사라지는 LSB값이 필요할 때가 종종 있다. 그래서 이 비트를 종종 조건 레지스터에 저장한다. 현재 CPU에서는 O비트에 저장한다고 가정하자.

여시거 설명 중인 시프트 명령어를 제외한 ALU의 모든 기능은 조합 논리로 구현할 수 있을 것 같다. 클록에 따랄 내용을 1비트씩 시프하는 시프트 레지스터(shift register)를 플립플롭을 사용해 만들 수 있다. 순차적인 시프트 레지스터는 1비트를 시프트할 때 한 클록이 필요하기 때문에 느리다.

기본 빌딩 블록인 셀렉터와 조합 논리를 사용하는 배럴 시프터(barrel shifter)를 사용하면 이런 문제를 해결할 수 있다. 8비트 시프터를 만들려면 8:1 셀렉터가 8개 필요하다. 

다이어그램을 보면 게이트, 먹스, 디먹스, 가산기, 래치 등의 기능은 모두 IC 디자인 시스템에서 사용할 수 있는 기성 부품으로 존재한다. 회로 보드에 부품을 수없이 연결해서 만드는 방식을 사용하는 대신에 칩 설계 소프트웨어를 통해 단일 칩 안에 여러 기성 부품을 조립할 수 있다.

ALU에 곱셈 나눗셈 연산이 없는 이유는 연산이 복잡하고  실제로 새로운 내용을 알려주지도 않기 때문이다. 곱셈은 덧셈을 반복하면되고 이 방식으로 순차논리로 곱셈을 구현할 수 있다. 왼쪽 시프트는 어떤 수를 2 곱한 것과 같다는 점에서 착안해 배럴 시프터와 가산기를 조합하는 조합 논리 곱셈기를 만들 수 있다.

시프터는 부동소수점 연산을 구현할 때도 핵심 부품이다. 두 피연산자의 가수를 지수에 따라 시프트함으로써 소수점을 정렬한 다음, 서로 더하거나 뺄 수 있다.



*실행 장치*

컴퓨터의 실행 장치(eexecution unit)는 제어 장치(control unit)라고도 알려저 있으며 대장 역할을 한다. 결국 ALU는 자체로는 유용하지 않고 누군가 할 일을 알려줘야 한다. 실행 장치는 메모리의 정해진 장소에서 명령코드와 피연산자를 가져와서 ALU에게 연산을 수행할지 알려준 뒤 결과물을 메모리에 돌려준다.

실행 장치가 이런 일을 어떻게 할 수 있을까? 우리는 실행 장치에게 명령어 목록을 제공한다. 이 명령어는 '위치 10에 있는 수를 12에 있는 수와 더해서 결과를 위치 14에 넣어라'같은 것이다. 실행 장치는 이런 명령어를 메모리에서 찾는다. 이런 방식의 컴퓨터를 프로그램 저장 방식 컴퓨터(stored program computer)라고 부른다. 이 아이디어는 앨런 튜링의 연구로부터 비롯되었다.

이제 비트를 살펴보고 해석하는 방법이 하나 더 생겼다. 명령어(instruction)는 컴퓨터에게 어떤 일을 할지 알려주는 비트 패턴이다. 명령어의 비트 패턴은 CPU마다 고유한 설계에 따른다. 숫자와 달리 명령어에는 공통 표준이 없다. 똑같은 'int a'라는 명령어라고 해도 인텔 CPU와 ARM CPU는 다른 비트 패턴을 사용할 가능성이 높다.

실행장치 명령어를는 프로그램 카운터(program counter)에서 위치를 알 수 있다. 프로그램 카운터는 레지스터의 일종이며 메모리와 별도의 특별한 곳에 위치한다. 프로그램 카운터는 순수 레지스터 대신 카운터로 이뤄진다. 카운터를 레지스터에 카운터 기능이 추가 된 것으로 생각하면 된다.

```
PC      메모리
		  3
		  2
          1
0  --->   0
```

프로그램 카운터에는 메모리 주소가 들어있다. 즉 프로그램 카운터는 메모리 위치를 참조(reference)한다. 실행 장치는 프로그램 카운터가 가리키는 주소에서 명령어를 읽어온다. 프로그램 카운터의 값을 바꾸는 특별한 명령어를 실행하는 경우가 아니라면 명령어를 수행한 뒤에 다음 명령어를 메모리의 다음 위치에서 가져올 수 있도록 프로그램 카운터가 증가된다.(명령어의 크기가 아닌 프로그램 카운터에 더해진다는 뜻이다.) CPU마다 정해진 초기 프로그램 카운터 값이 있으며 CPU 전원이 들어오면 PC는 이 값으로 설정된다.(이렇게 초기화 되는 PC값을 리셋 벡터(reset vector)라고 부르며 CPU마다 다르고 CPU가 리셋되는 원인에 따라 다른 리셋 벡터가 쓰일 수도 있다.) 

컴퓨터는 메모리의 정해진 위치에서 명령어를 찾고 다른 장소로 이동해 다음 명령을 찾는다. 이런 과정을 반복하면서 프로그램을 실행한다.





### 명령어 집합



*명령어*

어떤 종류의 명령어를 CPU에서 찾을 수 있을 지 살펴보고 명령어에 어떤 비트 패턴을 선택해야 할지 알기 위해 16비트 크기의 명령어를 사용하는 컴퓨터를 가정한다.

명령어를 명령코드, 두 피연산자, 결과라는 필드로 나누면 다음과 같다.

```
15 14 13 12 : 명령코드
11 10  9  8 : 피연산자 B
 7  6  5  4 : 피연산자 A
 3  2  1  0 : 결과
```

이렇게 필드를 나누는게 좋은 것 같지만 실제로는 잘 작동하지 않는다. 결과와 피연산자 주소에 4비트밖에 쓸 수 없기 때문이다. 사용할 수 있는 주소가 16개 뿐이라면 쓸모 있는 크기의 메모리를 가리킬 수 없다. 명령어를 더 크게 만들 수도 있지만 64비트 크기의 명령어를 사용해도 주소로 쓸 수 있는 크기는 20비트 뿐이다. 20비트로는 몇 메비바이트 밖에 처리할 수 있는 데 최신 컴퓨터는 기비바이트 이상 메모리를 사용할 수 있다.

또 다른 접근 방법은 DRAM 주소 지정 기법을 활용하는 것이다. 주소 확장 레지스터(address extension register)를 두고 별도의 명령어를 사용해 상위 주소(주소에서 MSB에 가까운 비트)를 지정한다. 이 방법은 인텔에서 32비트 CPU를 사용해 4GiB 이상의 메모리에 접근할 때 사용했던 방법이다. 인텔은 이를 '물리 주소 확장'이라고 불렀다. 주소 확장 레지스터에 값을 설정하려면 시간이 더 들고, 이런 접근 방식을 사용해 메모리 역역을 모두 지정하려면 여러 번 레지스터를 설정해야 한다는 단점이 있다.

하지만 3주소 명령어(three address)가 잘 작동하지 않는 더 중요한 이유가 있다. 3주소 명령어는 세 가지 메모리 위치를 한꺼번에 지정하는 (물리적으로 존재하지 않는) 메모리 주소 접근을 사용한다. 세 메모리 블록은 각기 다른 장치에 존재하며 주소 버스와 데이터 버스가 3개씩 따로 존재한다. 이 경우 연산 결과를 다른 연산에 활용하려면 결과가 들어 있는 메모리 장치에 있는 데이터를 다른 피연산자 메모리 장치로 보내기 위한 별도의 명령어를 사용해야 한다. CPU 패키지의 입출력 핀 수가 제한되어 있기 때문에 CPU 패키지를 늘리고 핀 개수를 늘리지 않으려면 세 버스가 같은 핀을 공유하고 다른 클록에 작동하는 수밖에 없다. 하지만 이런 식으로 처리한다면 버스를 3벌이나 둘 필요가 없다. 따라서 데이터 버스와 주소 버스를 하나만 두고 메모리 장치를 공유해야 한다. 

이 경우 피연산자A의 내용과 피연산자 B의 내용을 저장하는 레지스터를 추가해 명령어를 처리할 수 있다. 하드웨어는 다음과 같은 절차를 통해 명령어를 처리한다. 

1.  프로그램 카운터에 들어 있는 주소를 사용해 메모리에서 명령어를 읽어온다.
2. 명령어의 피연산자 A 부분에 있는 주소를 사용해 메모리에서 데이터를 읽어서 피연산자 A 레지스터에 저장한다.
3. 명령어의 피연산자 B 부분에 있는 주소를 사용해 메모리에서 데이터를 읽어서 피연산자 B 레지스터에 저장한다.
4. 연산을 수행한 결과를 명령어의 결과 부분에 있는 주소에 해당하는 메모리에 저장한다.

이런 명령을 수행하는 회로는 아주 복잡해진다. 각 단계를 한 클록에 수행한다면 명령어를 처리하기 위해 네 클록이 필요하다. 한 번에 한 메모리 위치에만 접근할 수 있다는 사실에 맞춰 명령어 집합을 적절히 설계해야 한다. 게다가 한 번에 한 주소에만 접근하면 좀 더 많은 비트를 주소에 활용할 수 있다.

레지스터에 다른 요소를 추가하면 이렇게 할 수 있다. 이 레지스터를 누산기(accumulator)라고 부른다.(누산기 레지스터를 A 레지스터라고 부르기도 한다.) 누산기는 ALU가 계산한 결과를 저장한다. 우리는 두 메모리 위치에 있는 값 사이에 연산을 수행해서 결과를 다른 메모리에 넣는 대신 한 메모리 위치에 있는 값과 누산기에 있는 값에 대해 연산을 수앻아고 결과를 누산기에 넣는다. 물론 누산기에 있는 값을 메모리에 저장하기 위한 저장(store) 명령어를 추가해야 한다. 그렇게 하면 명령어 구성은

```
15~12 : 명령코드
11~00 : 주소
```

이렇게 하면 더 많은 주소 비트를 사용할 수 있지만 같은 일을 할 때 더 많은 명령어가 필요하다.  예전에는 다음과 같은 일을 하는 명령어를  사용할 수 있었다.

```
C = A + B
```

하지만 이제는 3개의 명령어가 필요하다.

```
누산기 = A
누산기 = 누산기 + B
C = 누산기
```

한 명령어를 세 명령어로 바꿔서 명령어를 개선한 것 처럼 보이지 않을 수 있다. 간단한 경우에는 그렇게 보이지만 일반적으로는 성립하지 않는다.

```
D = A+B+C
```

위에서 네 가지 주소가 연관되기 때문에 3주소 명령어를 사용해도 이 식을 한 명령어로 처리할 수 없다. 이 식을 3주소 명령어로 처리하려면 다음과 같은 과정이 필요하다.

```
중간값 = A+B
D = 중간 값 +C
```

12비트 주소를 사용하면 세 가지 주소와 명령코드를 저장하기 위해 40비트 명령어를 써야 한다. 그리고 이런 명령어가 2개 필요하므로 D를 계산하기 위해 80비트의 명령어가 필요하다. 하지만 1주소 명령어를 사용하면 4개의 명령어를 사용하고 64비트가 필요하다.

```
누산기 = A
누산기 += B
누산기 += C
D = 누산기
```



*주소 지정 모드*

누산기를 사용하면 12비트를 주소 지정에 쓸 수 있고, 4,096가지 주소를 가리킬 수 있으면 16가지 주소를 가리킬 수 있는 것보다는 훨씬 낫지만, 여전히 사용가능한 주소가 충분하지 않다. 이런 방식으로 주소를 가리키는 경우를 직접 주소 지정(direct addressing)이라고 부른다. 이 말은 사용할 수 있는 주소가 명령어에 직접 들어가 있다는 뜻이다.

간접 주소 지정(indirect addressing)을 추가하면 더 많은 메모리를 사용할 수 있다. 간접 주소 지정 방식에서 CPU는 명령어에 들어 있는 값을 피연산자 주소로 해석하지 않고, 피연산자 주소를 얻을 수 있는 메모리 위치를 가리키는 주소로 사용한다. 예를 들어 메모리 주소 12에 4,321이라는 값이 들어 있고 메모리 주소 4,321에 345가 들어 있다고 가정하자. 직접 주소 지정과 12라는 값을 피연산자로 하는 load 명령어는 4,321을 누산기에 넣는다. 하지만 간접 주소 지정과 피연산자로 12를 사용하면 load 명령어는 345를 누산기에 넣는데, 이 값은 12번지에 들어있는 값인 4,321번 주소에 있는 내용이다.

이 두 가지 주소 지정 모드(addressing mode)만으로도 메모리를 다루기는 충분하다. 하지만 때로는 상수를 지정해야 할 때도 있다. 예를 들어 10까지 숫자를 세려면 10이라는 상수를 누산기에 넣을 방법이 필요하다. 이를 위해 즉시 주소 지정 모드(immediate addressing mode 주소를 지정하지 않고 직접 값을 지정하는 '즉시 모드'가 있다고 생각하면 혼동을 줄일 수 있다.)라는 또 다른 주소 지정 모드를 추가할 수 있다. 이 경우에는 주소에 해당하는 비트를 그냥 값으로 간주한다. 따라서 앞의 예의 경우 load 12를 즉시 지정 모드로 실행하면 12가 누산기에 들어간다. 

```
즉시 지정 모드 : 명령코드 | 12 ---> 12
직접 지정 모드 : 명령코드 | 345 ---> 345-메모리(12) ---> 12
간접 지정 모드 : 명령코드 | 4321 ---> 4321-메모리(345) ---> 345-메모리(12) ---> 12
```

분명히 직접 주소 지정은 즉시 주소 지정보다 느리다. 메모리에 두 번 접근(한 번은 명령어, 한 번은 메모리에서 데이터 읽기)해야 하기 때문에 때문이다.. 간접 주소 지정은 메모리에 세 번 접근해야 하기 때문에 더더욱 느리다.



*조건 코드 명령어*

지금까지 설명한 CPU 명령어 중에서 조건 코드를 다루는 명령에 대해 설명하지 않았다. 덧셈 뺄셈, 비교 연산에서 조건 코드가 설정된다는 사실을 살펴봤다. 하지만 조건 코드를 원하는 값으로 설정하거나, 조건 코드의 값을 살펴볼 수 있는 방법이 필요하다. 조건 코드 레지스터의 값을 누산기로 복사하는 cca라는 명령어와 누산기의 값을 조건 코드 레지스터에 복사하는 acc라는 명령어를 추가할 수 있다.



*분기 명령어*

지금은 명령어를 처음부터 끝가지 순서대로 수행할 수 밖에 없다. 의사 결정을 내리고 코드 중 일부를 선택적으로 실행할 수 있는 프로그램이 있다면 좋을 것이다. 이를 위해서는 프로그램 카운터의 값을 변경할 수 있는 명령어가 필요하다. 이런 명령어를 분기(branch) 명령어라고 부른다. 분기 명령어만으로는 순서대로 일련의 명령어를 실행할 수 있는 것에 비해 그다지 더 유용하지는 않다. 하지만 모든 분기 명령어가 항상 다른 주소로 분기(프로그램 카운터의 값을 바꿔서 다른 곳의 명령어를 실행함)하는 명령어 인 것은 아니다. 조건 코드를 살펴보고 어떤 조건을 만족 할때만 분기하는 명령어도 있다. 조건을 만족하지 않으면 다음 명령어가 실행된다. 분기 명령어에는 조건을 저장하기 위한 비트가 필요하다.

```
000 bra 항상 분기한다.
001 bov O(오버플로) 조건 비트가 1일 때 분기한다.
010 beq Z(영) 조건 비트가 1일 때 분기한다.
011 bne Z(영) 조건 비트가 0일 때 분기한다.
100 blt N(음수) 조건 비트가 1이고 Z(영) 비트가 0일 때 분기한다.
101 ble N(음수)과 Z(영) 비트 모두 1일 때 분기한다.
110 bgt N(음수)과 Z 모두 0일 때 분기한다.
111 bge N(음수)이 0이고 Z(영)가 1일 때 분기한다.
```

때로는 프로그램 카운터의 내용을 명시적으로 바꿀 필요가 있다. 이를 위한 두 가지 특별한 명령어가 있다. pca는 현재 프로그램 카운터 값을 누산기에 복사하고 apc는 누산기의 값을 프로그램 카운터에 복사한다.



*최종 명령어 집합 구성*

이 모든 기능을 우리 명령어 집합에 넣으면 다음과 같다.

```
15-14 : 모드 | 13-10 : 명령코드 | 09-00 : 주소
```

주소 지정 모드가 3가지 있으므로 2비트가 필요하다. 네번째 모드는 메모리와 관계없는 연산을 표현한다. 

주소 지정 모드와 명령코드를 디코딩하면 명령어를 얻을 수 있다. 분기 명령어를 명령코드에 추가했다는 점에 유의하라. 주소 지정 모드의 3의 명령코드는 누산기와만 관련된 명령어를 표현하기 위해 사용된다. 다만 이렇게 만든 완전한 구현은 ALU의 내용과 정확히 일치하지 않는다.

````
명령코드| 				주소 지정 모드
	  | 직접(00) | 간접(01) | 즉시(10) | 없음(11) |
0000  | load	| load	  | load 	|
0001  | and		| and	  | and		| set	  |
0010  | or		| or	  | or 		| not     |
0011  | xor		| xor 	  | xor 	| neg	  |
0100  | add 	| add 	  | add 	| shl	  |
0101  | sub 	| sub 	  | sub 	| shr	  |
0110  | cmp 	| cmp 	  | cmp 	| acc	  |
0111  | store	| store	  | 		| cca	  |
1000  | bra 	| bra 	  | bra 	| apc	  |
1001  | bov 	| bov 	  | bov 	| pca	  |
1010  | beq 	| beq 	  | beq		|		  |
1011  | bne 	| bne	  | bne		|		  |
1100  | blt 	| blt 	  | blt 	| 		  |
1101  | ble 	| ble	  | ble 	| 		  |
1110  | bgt 	| bgt 	  | bgt 	| 		  |
1111  | bge 	| bge 	  | bge 	| 		  |
````

왼쪽 시프트와 오른쪽 시프트는 다른 경우에 사용하지 않을 시프트할비트 수를 지정한다.

````
15 14 | 13 12 11 10 | 9 ~ 4 | 3 2 1 0 |
 1  1 |  0  1  0  0 |       |  비트 수  | : shl
 1  1 |  0  1  0  1 |       |  비트 수  | : shr
````

이제는 프로그램(program)을 작성해 실제 컴퓨터에게 어떤 일을 하라고 지시할 수 있다. 프로그램은 어떤 목표를 달성하는 일련의 명령어를 말한다. 피보나치 수열을 계산할 경우 0과 1에서 세 번째 수부터 그 전과 전전의 수를 계산하면 답이 된다. 짧은 기계어 프로그램은 이 과정을 구현한다. 과정에 따라 명령어를 세 필드로 구분했다. 설명에 있는 모든 주솟값은 10진수이고, 주소와 명령어에 있는 숫자는 모두 이진수이다.

```
주소  | 명령어 			    | 설명
0000 | 10 0000 0000000000 | 누산기를 0으로 만든다. 즉시 load 0
0001 | 00 0111 0001100100 | 누산기에 들어있는 값(0)을 메모리 위치 100에 저장한다.
0010 | 10 0000 0000000001 | 누산기에 1을 넣는다. (load 1)
0011 | 00 0111 0001100101 | 누산기에 들어있는 값(1)을 메모리 위치 101에 저장한다.
0100 | 00 0000 0001100100 | 메모리 위치 100에 들어 있는 값을 누산기로 가져온다.
0101 | 10 0100 0001100101 | 메모리 위치 101에 들어 있는 값을 누산기에 더한다.
0110 | 00 0111 0001100110 | 누산기에 들어있는 값을 메모리 위치 102에 저장한다. 
0111 | 00 0000 0001100101 | 메모리 위치 101에 들어 있는 값을 누산기로 가져온다.
1000 | 00 0111 0001100100 | 누산기에 있는 값을 메모리 위치 100에 저장한다.
1001 | 00 0000 0001100110 | 메모리 위치 102에 들어 있는 값을 누산기로 가져온다.
1010 | 00 0111 0001100101 | 누산기에 있는 값을 메모리 위치 101에 저장한다.
1011 | 10 0111 0001100101 | 누산기에 있는 값을 정수 200가 비교한다.
1100 | 00 0111 0000000100 | 바로 전에 비교한 결과가 참이면 메모리 위치 4(0100)로 분기한다.
```





### 마지막 설계

이제 모든 부분을 모아서 실제 컴퓨터로 만들어보자.



*명령어 레지스터*

컴퓨터가 프로그램을 한 번에 한 명령어씩 실행한다고 생각할 수 있지만 컴퓨터 내부에서는 많은 일이 벌어진다. 컴퓨터에서 벌어지는 일을 두 단계로 이뤄진 상태 기계(state machine)으로 설명할 수 있다.

```
패치 <-> 실행
```

처음에 컴퓨터가 해야 하는 일은 메모리에서 명령어를 가져오는 페치(fetch)이다. 그리고 이 명령어를 어떻게 실행할지 고민한다.

명령어를 실행하려면 메모리에 접근해야 할 경우가 많다. 이 말은 다른 목적으로 메모리를 사용할 때 페치한 명령어에 편하게 접근할 수 있도록 저장할 다른 위치가 필요하다는 듯이다. CPU에 명령어 레지스터(instruction register)를 추가해서 현재 실행 중인 명령어를 저장한다.

```
프로그램 카운터 - 주소 버스 -> 메모리 - 데이터 버스 -> 명령어 레지스터
```



*데이터 경로와 제어 신호*

이제 복잡한 부분이다. 프로그램 카운터의 값을 메모리 주소 버스에 넣을 방법과 메모리에 있는 데이터를 명령어 레지스터로 넣을 방법이 필요하다. 이런 고민을 계속해서 여러 명령어 집합을 구현하는 데 필요한 모든 연결을 결정해야 한다.

간접 주소 레지스터(indirect address register)는 간접 주소 지정을 사용할 때 메모리에서 읽어온 주소를 어딘가에 저장할 때 사용된다. 이는 명령어 레지스터에 메모리에서 읽어온 명령어를 저장하는 것과 비슷하다.

간단한 레지스터와 마찬가지로 레지스터에는 다음 클록 틱에 데이터가 저장된다. 프로그램 카운터와 메모리도 제어 신호가 지시하는 동작을 클록에 맞춰서 수행한다. 셀렉터 등 다른 구성요소는 클록이 필요하지 않다.



*데이터 흐름 제어*

입출력에 대해 알았으므로 교통을 제어하는 장치에 대해 만들 때다. 이 장치가 어떻게 작동해야 할 지 예시를 살펴보자.

어떤 명령어든 처리를 하기 위해서는 페치를 해야 한다. 페치를 하려면 다음 같은 신호가 필요하다.

- address source는 프로그램 카운터를 선택해야 한다.
- 메모리를 동작시켜야 한다.(enable=1)그리고 r/w는 읽기(1)로 설정해야 한다.
- 명령어 레지스터를 동작시켜야 한다.(enable=1)

다음 예제로는 누산기의 값을 명령어의 주소 부분이 가리키는 메모리에 있는 값에 해당하는 주소에 저장하는 경우를 생각하자. 페치는 다음대로 수행할 수 있다.

간접적으로 주소를 메모리에서 가져오기 위해 다음과 같은 신호를 설정해야 한다.

* address source를 명령어 레지스터로 지정한다. 이 경우 명려어 레지스터의 주소 부분이 주소 버스에 연결된다.
* 메모리를 동작시켜야 한다.(enable=1) 그리고 r/w는 읽기(1)로 설정해야 한다.
* 간접 주소 레지스터를 동작시켜야 한다.(enable=1)

클록 틱이 지나면 간접 주소 레지스터에 명령어의 주소 부분이 가리키던 주소에 있던 값이 들어간다. 이제 누산기에 있는 값을 이 주소에 저장한다.

* address source를 간접 주소 레지스터로 설정해야 한다.
* data bus enable=1로 설정해야 한다.
* 메모리를 동작시켜야 한다.(enable=1). 그리고 r/w는 쓰기(0)으로 설정해야 한다.
* 프로그램 카운터를 증가시킨다.(ld/cnt=0)

페치와 실행에 여러 단계가 필요하므로 각 단계를 추적할 카운터가 필요하다. 이 카운터의 내용과 명령코드와 모드 부분이 제어 신호를 결정한다. 가장 복잡한 연산의 경우 3단계가 필요하기 때문에 카운터는 2비트 카운터여야 한다. 

```
	       <--- 재설정
클록 -> |  카운터  | 
```

그림의 큰 박스는 랜덤 논리(random logic)라는 것으로 가득 차 있다. 지금까지 살펴본 논리 다이어그램은 일반적인 패턴을 따른다. 셀렉터나 레지스터 등의 기능 블록은 더 간단한 블록을 정해진 패턴으로 조합해 만들어진다. 복잡한 구조를 구현하는 경우, 정해진 개수의 입력이 있고 이 입력들을 정해진 개수의 출력에 연관시켜야 하는 데 출력에 어떤 규칙성이 없을 때도 있다. 이런 경우 회로도가 마치 쥐 둥지가 얽히고설킨 것처럼 보인다. 여기서 '랜덤'이라는 말이 나왔다.

하지만 또 다른 랜덤 논리 대신 적당한 크기의 메모리를 사용할 수도 있다. 이때 카운터의 출력과 명령어의 명령코드와 주소 지정 모드 부분을 메모리 주소에 연결한다.

이런 방법은 좀 이상해 보일 수도 있다. 반면 이 또한 랜덤 논리 대신 메모리를 사용해 구현한 또 다른 상태 기계일 뿐이다. 한편 이 자체로도 작은 컴퓨터 같아 보인다. 이 두 가지 해석은 모두 옳다. 컴퓨터는 상태 기계이기 때문에 이 회로 역시 상태 기계다. 프로그래밍이 가능하기 때문에 이 회로도 컴퓨터다.

이런 식으로 구현하는 방법을 **마이크로코드를 썼다**라고 한다. 이때 메모리 내의 내용이 마이크로코드(microcode)라고 한다. 우리는 큰 컴퓨터를 구현하기 위해 작은 컴퓨터를 사용한다.

이제 우리가 설명한 예제를 구현해주는 마이크로명령어(microinstruction) 부분을 살펴보자. 

명령어 집합을 구현하는 마이크로코드를 사용한 블록을 구현하기 위해 나노코드를 사용하는 컴퓨터도 존재한다. 

마이크로코드 메모리로 ROM을 사용하면 좋다. ROM을 쓰지 않는 다면 어딘가에 마이크로코드를 저장했다가 필요할 때 마이크로코드를 불러오는 회로가 필요하다. 하지만 상황에 따라 RAM을 사용하거나 ROM과 RAM을 섞어서 사용하기도 한다. 일부 인텔 CPU는 버그를 수정하기 위해 패치(patch : 코드의 일부 혹은 전부를 덮어씀)할 수 있는 쓰기 가능한 마이크로 코드를 포함하기도 한다. HP-2100 같은 일부 컴퓨터에는 쓰기 가능한 제어 저장소(writable control store)가 있다. 이 저장소는 명령어 집합을 확장하기 위해 쓸 수 있는 마이크로코드를 저장하는 RAM이다.

오늘날 마이크로 코드를 제공하는 컴퓨터 중에 일반 사용자가 마이크로코드를 변경할 수 있도록 허용하는 경우는 드물다. 마이크로코드에 버그가 있다면 컴퓨터에 해를 끼칠 수도 있기 때문이데 예를 들어 CPU를 활성화 하면서 동시에 데이터 버스가 활성화 되면 토템-폴 출력이 서로 연결되면서 내부 트랜지스터가 타버린다.





### RISC와 CISC 명령어 집합

설계자들은 유용한 명령어를 만들었지만 명령어가 복잡해지면서 컴퓨터 제어 회로가 복잡해졌다. 1980년대 버클리의 데이비트 패터슨과 존 헤네시가 여러 프로그램을 분석한 결과 복잡한 명령어의 상당수는 사용되지 않고 있었다. 이들은 프로그램 실행 시간을 대부분 차지하는 명령어만을 포함하는 기계를 설계하는 개념을 처음으로 탐구했다. 이런 기계에서는 복잡한 명령어를 단순한 명령어를 조합해 처리한다. 이를 RISC(reduced instruction set computer) 기계라고 부른다. 이와 달리 기존 설계 방식으로 만든 컴퓨터를 CISC(complicated instruction set computer) 기계라고 부른다.

RISC 기계의 중요한 특징으로는 적재-저장구조(load-store architecture)를 사용한다는 점을 꼽을 수 있다. 이 아키텍쳐는 메모리와 레지스터를 오가는 명령어들과 레지스터 간 명령어로만 이뤄진 구조다.

물론 시간이 지나며 컴퓨터도 달라져 왔다. 패터슨과 헤네시의 통계는 컴퓨터가 비디오나 오디오 처리에 널리 쓰이기 이전의 데이터를 분석한 것이다. 하지만 더 새로운 프로그램들을 분석한 결과 CPU 설계자들은 새로운 명령어를 RISC 기계에 추가하게 됐다. 이로 인해 최근의 RISC 기계는 오래전의 CISC 기계보다 훨씬 복잡하다.

큰 영향을 끼친 CISC 기계로는 디지털 이큅먼트의 PDP-11을 들 수 있다. 이 기계에는 ALU 역할을 할 수 있는 범용 레지스터가 8개 있었다. 게다가 자동증가, 자동감소 주소 지정 모드를 지원했다. 이 두 모드는 레지스터를 사용하기 이전이나 후에 레지스터에 들어 있는 값을 감소시키거나 증가시켜주는 모드다. 이런 모드가 있다면 몇 가지 프로그램을 효율적으로 작성할 수 있다. 어떤 원본 주소(source address)로부터 다른 대상 주소(destination address)로 n바이트의 메모리를 복ㅅ하고 싶다고 하자. 이런 복사를 수행하는 프로그램은 다음과 같다.

```
0 > 0번 레지스터가 가리키는 메모리 위치에 있는 값을 2번 레지스터가 가리키는 메모리 위치로 복사한다. 그 후 두 레지스터에 1을 추가한다.(자동 증가)
1 > 2번 레지스터에 들어있는 값에서 1을 빼고 이 값을 0과 비교한다.(자동 감소)
2 > 비교 결과가 0이 아니면 0번 주소로 분기한다.
```

C 프로그래밍 언어는 B라는 언어로부터 만들어진 것인데, C언어가 PDP-11에서 처음 만들어졌다. C에 있는 포인터(pointer)는 간접 주소 지정을 추상화한 것인데, B 언어에서 가져온 자동증가와 자동감소 기능이 포인터와 잘 어우러진다. 그리고 PDP-11 구조에서는 C의 포인터와 자동증가/자동감소를 아주 쉽게 기계어로 번역할 수 있다. C는 널리 쓰이게 되었고 C++, 자바, js 같은 언어에 많은 영향을 끼쳤다.



### GPU

그래픽 처리 장치(graphics processing unit)

컴퓨터를 사용한 그래픽은 마치 번호에 맞춰 색을 칠하는 아주 커다란 컬러링 책과 같다. 칠해야 할 지점이 800만개가 넘는 경우도 많고 비디오를 매끄럽게 처리하려면 이런 그림을 초당 60회 이상 그러야 한다. 이로 인해 매초 수 억번 이상 메모리에 접근해야 하는 경우도 많다.

그래픽 처리는 아주 특화된 과정이기 때문에 일반적인 CPU가 제공하는 모든 기능이 필요하지 않다. 여러 점을 동시에 찍으면 성능이 향상될 수 있기 때문에 그래픽은 병렬화(parallelize)하기 좋은 작업이기도 하다.

GPU를 특정 짓는 기능은 두 가지가 있다. 첫 째 GPU에는 간단한 처리 장치가 아주 많이 들어 있다. 둘 째 GPU는 CPU보다 메모리 버스의 폭이 더 넓다. 이로 인해 메모리에 더 빠르게 접근할 수 있다.

시간이 지남에 따라 GPU도 일반적인 용도에 쓰일 수 있게 됐다. 여러가지 표준 프로그래밍 언어로 GPU를 프로그래밍할 수 있게 하려는 노력이 진행됐다. GPU 구조의 이점을 살릴 수 있는 여러 응용분야(공학 계산, 인공지능)에 GPU를 사용할 수 있다.





### 정리

4장에서는 여러 요소를 통해 실제 컴퓨터를 만들었다. 간단한 여기서 설계한 기계는 실제로 프로그래밍도 가능하다. 하지만 이 컴퓨터에는 실제 컴퓨터에 있는 스택이나 메모리 관리 하드웨어 등 몇 가지 요소가 빠져 있다. 5장에서는 여기에 대해 시작한다.


























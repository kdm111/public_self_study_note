## 웹 브라우저

> 추상적인 컴퓨터를 이해하기 위한 가상 머신



웹 브라우저는 그 자체가 가상머신(virtual machine)이다. 즉 웹 브라우저는 아주 복잡한 명령어 집합을 완전히 소프트웨어로만 구현한 추상적인 컴퓨터다. 다시 말해 웹 브라우저는 8장에서 배운 인터프리터에 속한다.

이번 장에는 이 가상 머신의 기능을 살펴본다. 웹 브라우저의 입력 언어와 이 입력 언어를 어떻게 웹 브라우저가 실행하는지 배운다. 하지만 브라우저는 아주 복잡하기 때문에 모든 기능을 다룰 수 는 없다.

브라우저를 배울 때 흥미로운 점은 브라우저가 크고 복잡한 애플리케이션인 동시에 소프트웨어로 구현된 프로그래밍할 수 있는 컴퓨터이기도 하다는 점이다. 브라우저에는 개발자 콘솔(developer console)이 있다. 이를 통해 이번 장에서 보여주는 여러 예제를 돌려볼 수 있고 어떻게 작동하는지 실시간으로 살펴볼 수 있다.

웹 브라우저를 이해하면 시스템 설계에 대해서도 어느 정도 이해할 수 있다. 그리고 시스템 설계는 분명 프로그래밍보다 더 중요하다. 웹이 유명해지면서 다양한 기능이 추가됐다. 이렇게 추가된 기능중 상당수는 원래 브라우저가 제공하던 명령어 집합과 호환이 되는 방식으로 브라우저 기능을 확장했다. 하지만 일부 기능은 기존 방식과 호환되지 않는 방식으로 기존 기능과 중복되는 기능을 제공한다. 그 결과 브라우저마다 각기 다른 명령어 집합을 제공하며 어느 브라우저도 완전한 명령어 집합을 제공하지 못하는 상황이 됐다. 





### 마크업 언어

HTML(hyper text markup language)은 새로운 기능을 끌어모아 기능이 커지고 있다. 이런 식으로 늘어난 기능 중에는 여러 마크업 언어도 있다. 그래서 여기서는 먼저 마크업 언어에 대해 다룬다.

마크업(markup)은 본문(텍스트)과 구분할 수 있는 마크(mark)를 추가할 수 있는(이를 애노테이션(annotation)이라고 한다.) 시스템이다.

마크업 언어는 새로운 개념이 아니다. 컴퓨터가 생기기 전부터 마크업 언어가 있어왔다. 인쇄술의 부작용으로, 작가와 편집자들은 조판(typesetting)을 담당하는 인쇄공에게 자신이 원하는 사항을 묘사해 전달할 필요가 생겨났다. 이럴 때 사용하는 유용한 표기법이 컴퓨터를 이용해 자동화된 조판 시스템에도 전해 내려왔다. 요즘 마크업 언어는 오래된 아이디어를 최근에 살린 것 뿐이다.

많은 마크업 언어가 있다. 다음은 troff라는 마크업 언어의 예이다.

```
.PP
There are a large number of markup languages.
For example, I originally wrote this book in a markup language for typesetting
call \fCtroff\fP.
The source for this paragraph is shwon in Listing 9-1
```

대부분은 그냥 텍스트이고 세 가지 마크업이 사용됐다는 사실을 이 리스트를 통해 알 수 있다. .pp는 troff에게 문단을 시작하라고 지시한다. \fC는 troff에게 현재 글꼴을 스택에 넣고 C 글꼴로 바꾸라고 지시한다. \fP는 troff에게 글꼴을 스택에서 꺼내라고 지시한다. 그 결과 텍스트를 표시하는 글꼴이 이전의 글꼴로 원상 복귀 된다.

웹 페이지는 그냥 텍스트 파일에 지나지 않는다. 웹 페이지를 만들기 위해 특별히 멋진 프로그램을 쓸 필요는 없다. 사실은 웹 페이지 생성 프로그램이 너무 많은 마크업까지 붙은 큰 파일을 만들어낸다. 직접 손으로 만든다면 더 간결하게 만들 수 있다.

일반 텍스트 파일을 어떻게 마크업할수 있을까? 일부 문자에 특별한 힘을 부여하면 된다. torff는 .이나 '로 시작하는 경우나 \로 시작하는 문자에 특별한 힘을 부여한다.

IBM은 GML이라는 자신만의 마크업 언어를 만들었다. GML은 일반화한 마크업 언어의 약자이다. 이들의 작업을 확장해 표준 GML이 만들어졌고 ISO에게 표준으로 채택되었다.

확장 가능한 마크업 언어(XML : eXtensible Markup Language)는 좀 더 실용적인 SML의 하위 집합이다. 브라우저는 나중에 XML을 지원하게 되었다.

HTML과 XML 모두 SGML을 뿌리로 한 언어다. 이들은 똑같은 SGML 언어로부터 문법을 일부 빌려왔지만 SML 표준을 준수하지는 않는다.

XHTML은 HTML을 변형한 형태로 XML 규칙을 준수하기로 만들어진 언어다.





### 균일 자원 위치 지정자

최초의 웹 브라우저(WorldWideWeb)은 영국의 팀 버너스리 경에 의해 1990년 경 만들어졌다. 당시 브라우저는 다음과 같이 간단하게 작동했다.

```
       -URL-> 
브라우저        서버
       <-문서-
```

브라우저는 균일 자원 위치 지정자(URL : Uniform Resource Locator)를 사용해 244페이지의 월드 와이드 웹 절에서 설명한 HTTP 프로토콜을 통해 서버에게 문서를 요청한다. 서버는 문서를 브라우저에게 보내고, 브라우저는 문서를 표시한다. 이때 사용되는 문서는 HTML을 통해 작성됐지만 이제는 다양한 언어로 작성된 문서를 사용할 수 있다.

URL은 일정한 구조를 따르는 텍스트 문자열이다. 지금은 세 가지 부분만 신경을 쓰면 된다.

```
https://leetcode.com/problemset/all/
-스킴--------호스트--------경로--------
```

스킵(scheme)은 통신 메커니즘을 표시한다. https는 안전한 하이터 텍스트 전송 프로토콜을 뜻한다. 통신하려는 서버가 호스트(host)다. 호스트 주소는 숫자로 된 인터넷 주소일 수도 있지만 보통은 도메인 이름을 사용한다. 문서는 경로(path)가 가리키는 위치에서 추출된다. 경로는 일반 파일 시스템 경로와 비슷해보인다.

스킴 중에는 file이 있다. file을 스킴으로 사용하면 URL의 호스트와 경로가 로컬 파일 경로(브라우저가 실행 중인 컴퓨터에 있는 파일의 경로와 이름)로 된다. 다시 말해, file 스킴을 사용하면 컴퓨터에 있는 파일을 가져올 수 있다.

스킴은 계속해서 늘어나고 있다. bitcoin은 비트코인 암호화폐를 가리키며 tv는 텔레비전 방송을 가리킨다. 스킴은 대부분 월드 와이드 웹에서 살펴봤던 프로토콜과 비슷하거나 동일하다.





### HTML 문서

최초의 웹 페이지는 HTML로 작성됐다. HTML은 하이퍼텍스트(hypertext)를 활용한다. 하이퍼텍스트는 웹 페이지 등 다른 대상에 대한 링크가 들어 있는 텍스트를 말한다. 링크를 누르면 다른 장소로 옮겨갈 수 있다. 하이퍼텍스트는 오래된 아이디어이지만, 웹이 가장 흥미로운 응용이였다.

```html
<html>
    <head>
        <title>first web page</title>
    </head>
    <body>
        web page
        <b>
        	<big>Cool!</big>
        </b>
    </body>
</html>
```

html에서 부등호(<)는 특별한 힘을 갖는다. 여기서 <는 마크업 엘리먼트(element)를 시작한다. 엘리먼트는 쌍으로 끝난다. 

태그는 브라우저가 마크업 엘리먼트를 어떻게 해석할지를 결정한다.

<에 특별한 능력을 부여했기 때문에 이런 능력이 필요 없을 때는 어떻게 표시할 수 있을 지 궁금할 것이다. HTML에는 <의 능력을 뺏을 수 있는 엔티티 참조(entity reference)가 있다. 엔티티 참조는 문자를 다른 문자열로 표현하는 방법이다. HTML에서는  &`lt;`라는 문자 시퀀스를 사용해 특별한 능력 없이 <를 표현할 수 있다. (물론 이로 인해 &라는 문자가 생겨났지만 &역시 `&amp;`라는 엔티티 참조로 표현할 수 있다.) 에닡티 참조를 사용하면 '이 페이지는 `&lt;`가 들어 있는 첫 번재 페이지입니다.'라고 쓸 수 있고 이 문장은 브라우저에서 제대로 표시된다.

HTML 엘리멘트는 단순하지만은 않다. 끝나는 태그를 쓰지 않아도 되는 경우가 있는 데 이런 예외가 규칙적이지는 않다. 그리고 엘리멘트 안에 아무 내용이 없으면 `<tag/>`처럼 여는 태그와 닫는 태그를 하나로 묶어서 쓰는 형태도 있다. XHTML은 이런 예외를 없앴다. 그리고 애트리뷰트(attribute)라는 다른 요소에도 신경을 써야 한다. 태그에는 애트리뷰트가 포함될 수 있는 데 애트리 뷰트는 이름과 값을 `=`로 연결한 쌍이다.

```html
<<tag name1="value1" name2="value2" ...>
	엘리멘트 내용
</tag>
```

애트리뷰트 이름에 따라 미리 정의된 동작이 있는 경우도 있다. 이런 동작이 미리 정의되지 않은 이름이라면 아무 이름이나 애트리뷰트에 사용할 수 있다. class 애트리뷰트를 제외하면 모든 애트리뷰트값은 똑같이 문자열처럼 취급딘다. class 애트리뷰트의 값은 공백으로 서로 분리된 값의 리스트로 취급된다.





### DOM : 문서 객체 모델

웹 브라우저는 문서를 문서 객체 모델(DOM : document object model)에 따라 처리한다. 리스트에서 들여쓰기를 통해 보여주듯이 일련의 엘리멘트들이 다른 엘리멘트를 둘러싸고 있는 것으로 웹 페이지를 생각할 수 있다.

이는 마치 DAG이기도 하고 트리 구조 이기도 하다. 그뿐이 아니다. HTML을 8장에서 다룬 기법을 사용해 처리하면 파스 트리를 얻을 수 있다.

* 트리 관련 용어

  DOM과 같은 트리 구조가 아주 흔하기 때문에 이런 구조를 설명할 때 편하도록 여러 가지 용어가 만들어졌다.

  | 용어                   | 의미                                                         | 예제                          |
  | ---------------------- | ------------------------------------------------------------ | ----------------------------- |
  | 노드(node)             | 트리를 이루는 엘리멘트들                                     | html, head, body              |
  | 내부(interior) 노드    | 자신에게서 나가는 화살표가 존재하는 노드                     | title                         |
  | 종단(terminal) 노드    | 자신에게서 나가는 화살표가 없는 노드(leaf)                   | 엘리멘트 내용                 |
  | 루트(root)             | 트리의 최상위 노드                                           | html                          |
  | 부모(parent)           | 두 노드를 연결하는 화살표가 있는 경우 화살표의 출발점에 있는 노드 | html은 head, body의 부모이다. |
  | 자식(child)            | 두 노드를 연결하는 화살표가 있는 경우 화살표의 끝점에 있는 노드 | head, body는 html의 자식이다. |
  | 후손, 자손(descendant) | 직간접적으로 다른 노드의 자식이거나 자식의 자식 등의 관계가 있는 노드 | title은 html의 자손 노드이다. |
  | 선조, 조상(ancestor)   | 직간접적으로 다른 노드의 부모이거나 부모의 부모 등의 관계가 있는 노드 | body는 b의 선조이다.          |
  | 형제, 자매(sibling)    | 한 부모의 자식인 노드 간의 관계                              | head는 body의 형제이다.       |

  트리에 있는 노드는 순서가 정해져 있다. head는 html의 첫 번째 자식이고 body는 html의 두 번째이자 마지막 자식이다.

* DOM 처리

  브라우저가 문서 트리로 어떤 일을 할까? 세상에 DOM 파스 트리를 기계어로 컴파일할 일은 없다. 그 외의 문서 트리로 할 수 있는 일은 dfs를 하면서 트리를 해석하는 일이다.

  브라우저는 루트에서 첫번째 자식으로 내려가고 그 자식의 첫 번째 자식으로 내려간다. 종단에 도달할 때까지 순회를 반복한다. 이후 종단 노드의 부모로 돌아가 그 부모의 또 다른 자식 노드를 방문한다. 이 과정을 모든 노드를 방문할 때까지 반복한다. 여기서 방문하는 순서가 HTML을 작성한 순서를 따른다는 사실을 확인하라. 깊이 우선 순회는 스택을 사용하는 또 다른 예이다.





### CSS

HTML을 뒷받침하는 아이디어는 웹 페이지를 작성한 사람이 HTML로 페이지를 작성하면 브라우저가 웹 페이지를 표시해줄 방법을 스스로 알아내는 것이다. 브라우저의 창 크기, 화면 해상도, 사용할 수 있는 색이나 글꼴 등을 알 방법이 없기 때문에 이런 아이디어는 정당했다.

웹이 유명해지면서 마케터들이 웹에 관여하기 시작했다. 화면의 시각적 효과가 중요해졌다. HTML을 작성하는 사람이 페이지가 표시되는 모습을 더 세밀하게 조정할 수 있도록 갖가지 기능이 (새로운 CSS 명세를 통해) 추가됐다.

원래 HTML 웹 페이지에는 스타일 정보가 들어 있었다. font 엘리멘트는 face 애트리뷰트로 글꼴, size로 크기, color로 색을 지정할 수 있었다. 웹 페이지가 핸드폰에서 데스크탑에 이르는 광범위한 장치에 표시될 수 있었기 때문에 이런 접근 방법은 제대로 작동하지 않았다. 캐스케이딩 스타일 시트(Cascading Style Sheets) 즉 CSS는 HTML에서 스타일 정보를 분리해서 HTML을 한 번만 작성해도 대상 장치에 따라 여러 스타일을 적용할 수 있게 했다.

```
                엘리멘트
                tag -> name
                <- previous
                next -> 
                attributes -> next -> next
            |   firstchild    name    name 
            |                 value   value
엘리멘트   <---   lastchild  -> 엘리멘트  
previous   <-                 previous
next ->                       next
```

엘리멘트와 애트리뷰트를 표현하는 복합 데이터 타입이 있다. 애트리뷰트는 단일 연결 리스트로 구성된다. 엘리멘트들은 트리로 배열된다. 자식이 얼마든지 있을 수 있고 순서가 중요하므로 자식들은 이중 연결 리스트로 다뤄진다.

CSS가 셀렉터(selector)라고 하는 정규식의 변형을 사용해 DOM의 엘리멘트 위치를 지정하므로 구성요소를 어떻게 구성하느냐가 중요하다. 셀렉터를 통해 엘리멘트를 배치시키는 것은 yacc이 스택에서 토큰을 매치하는 것과 비슷하다. CSS는 선택된 엘리멘트와 애트리뷰트를 연결해준다. 이를 통해 웹 페이지 디자이너는 대상 장치에 따라 텍스트 크기를 조정하거나 화면이 작은 장치에 대해 사이드 메뉴를 드롭다운 메뉴로 줄여주는 등의 일을 할 수 있다.

CSS는 여러 용어의 범벅이다. CSS는 색, 글꼴 크기 등의 많은 프로퍼티를 정의한다. DOM 엘리멘트와 결합된 프로퍼티를 애트리뷰트라고 부른다.

CSS 셀렉터 중 일부를 보여준다. 원래는 몇 가지 셀렉터만 있었지만 아주 놀라운 속도로 새로운 셀렉터가 추가돼왔다.

``` 
패턴  의미
 * : 아무 엘리멘트나 매치된다.
 E : 아무 E 엘리멘트와 매치된다.
 F : 아무 F 엘리멘트와 매치된다.
 E F : E 엘리멘트의 후손인 F 엘리멘트와 매치된다.
 E > F : E 엘리멘트의 자식인 F 엘리멘트와 매치된다.
 E + F : E 엘리멘트 바루 뒤에 형제자매로 있는 F 엘리멘트와 매치된다.
 E - F : E 엘리멘트 바로 앞에 형제자매로 있는 F 엘리멘트와 매치된다.
 E[이름] : '이름'에 해당하는 애트리뷰트가 있는 E 엘리멘트와 매치된다.
 E[이름=값] : '이름'에 해당하는 애트리뷰트값이 '값'인 E 엘리멘트와 매치된다.
 E[이름~=값] : '이름'
 E#아이디 : id 애트리뷰트값이 '아이디'인 E 엘리멘트와 매치된다.
 E.클래스 : class 애트리뷰트값이 '클래스'인 E 엘리멘트와 매치된다.
 E:first-child : E가 형제자매 중 첫 번째 엘리먼트인 경우에만 매치된다. 
 E:last-child : E가 형제자매 중 마지막 엘리멘트인 경우에만 매치된다.
 E:nth-child : E가 형제자매 중 n번째 엘리멘트인 경우에만 매치된다.
 E:empty : 자식이 없는 E 엘리멘트와 매치된다.
 E:link : 아직 방문한 적이 없는 E 엘리멘트(<a>등 하이퍼링크가 있는 엘리멘트)와 매치된다.
 E:visited : 방문한 적이 있는 E 엘리멘트(<a>등 하이퍼링크가 있는 엘리멘트)와 매치된다.
 E:hober : 마우스 포인터를 E 엘리멘트 위로 이동했을 때, E와 매치된다.
 E:active : 사용자가 E 엘리멘트를 마우스 등으로 활성화 하는 경우 매치된다.
 E:focus : 입력 포커스가 있는(엘리멘트가 키보드 입력을 받을 때) E 엘리멘트와 매치된다.
```

스타일 시트는 다음과 같이 작성될 수 있다.

```html
<style>
    body {
        color : blue;
    }
    big {
        color : yellow;
        font-size : 200%;
    }
</style>
```

body와 big이라는 엘리멘트를 선택한뒤 각 셀렉터 뒤에는 프로퍼티의 이름과 값이 들어가 있다. 이름과 값은 콜론으로 구분되며 셀렉터에 대한 프로퍼티의 목록은 중괄호에 들어가 있다. 

css는 나중에 나온 아이디어이다. HTML을 개발할 때는 아무도 이를 생각하지 못했다. 그 결과 꽤 이상한 요소가 있다. HTML 안에는 미리 정의된 다양한 엘리멘트가 있다. `<b>`는 텍스트를 굵게 만들고 `<i>`는 기울인 글꼴로 만든다. 하지만 CSS를 사용하면 의미를 반대로 바꿀 수 있다.

```html
<style>
    b {
        font-style : italic;
        font-weight : normal;
    }
    i {
        font-style : normal;
        font-weight : bold;
    }
</style>
```

CSS는 여러 HTML 원소들 사이의 구분을 각 원소의 의도 및 목적과 관계없이 없애버렸다. HTML 엘리멘트들이 디폴트 스타일이 있다고 생각하는 사람들도 있겠지만 CSS를 통해 스타일이 바뀌고 나면 원소 이름은 아무 의미가 없게 된다.

CSS는 원래 애트리뷰트를 엘리멘트와 연관시키는 더 유연한 매커니즘을 제공하기 위해 고안됐다. 이를 통해 HTML에 없던 애트리뷰트가 엘리멘트에 추가됐다. 이로인해 HTML과 CSS에서 일부 애트리뷰트를 동시에 설정할 수 있고, 나머지를 CSS에서 설정할 수 있다. 프로그래머 사회에서는 예전 방식의 애트리뷰트 설정을 아예 사용하지 말아야 한다는 입장이 꽤 강하다.





### XML 등의 마크업 언어

XML은 HTML과 꽤 비슷해 보인다. 하지만 SGML과 마찬가지로 XML도 잘 만들어진 엘리멘트를 요구한다. 이 말은 `<tag>`로 연 엘리멘트는 `</tag>`로 닫아야 한다는 뜻이다. 암시적인 닫는 태그는 사용할 수 없다. HTML과 XML의 큰 차이는 HTML은 웹 페이지라는 구체적인 응용을 위해 만들어진다는 점이다. XML은 더 일반적인 용도의 마크업 언어로 다양한 응용분야가 있다.

대부분의 XML 태그는 미리 정해진 의미가 없다. 원하는 대로 태그에 의미를 부여할 수 있다. XML은 응용 분야에 따라 원하는 대로 마크업 언어를 정의할 수 있는 구조를 제공한다. 

```xml
<xml>
	<garden>
    	<vegetable>
        	<name>tomato</name>
            <days>80</days>
        </vegetable>
    </garden>
</xml>
```

하지만 누구나 원하는 대로 마크업 언어를 만들수 있으므로 충돌이 발생할 수 있다. 중복된 태그가 존재할 때 어떤 언어의 태그인지 확인하게 해주는 매커니즘이 필요하다. 엘리멘트 태그 앞에 접두사를 붙이는 방법이 바로 이 매커니즘인데 이 방법을 이름 공간(namespace)라고 부른다.

이름 공간을 지정하는 방법은 다양하지만 각 이름 공간에는 URL이 연결된다. 이 URL이 올바른 URL이어야 한다는 요구사항은 없다. 단지 다른 이름 공간과 구별할 수 있으면 된다. `<xml>` 엘리멘트의 `<xmlns>` 애트리뷰트는 이름 공간 접두사와 URL을 연결해준다. 다음은 적절히 섞인 모습을 보여준다.

```xml
<xml xmlns:vml="http://www.garden.org" xmlns:rml="http://www.recipe.org">
	<vml:garden>
        <vml:name>tomato</vml:name>
        <vml:days>80</vml:days>
    </vml>
    <rml: name>tomato soup</rml>
</xml>
```

설명을 위해 만든 두 마크업 언어의 엘리멘트를 함께 사용하고 접두사를 보고 두 언어의 태그를 구분할 수 있음을 알 수 있다. 이름 공간 접두사를 임의로 지정할 수 있고 함께 엮어서 사용해야 하는 각기 다른 모든 마크업 언어에 대해 지정할 수 있다. `rml`이 레시피 마크업 언어  대한 접두사여야 한다는 규칙은 없다. 따라서 `rml`은 다른 단어 `recipe`와 바뀔 수 있다.

마크업 언어 같은 커스텀 언어 같은 커스텀 마크업 언어를 더 잘 이해할 수 있게 해주는 도구가 많이 있다. 그리고 다양한 프로그래밍 언어로 구현된 XML 문서로부터 파스 트리를 만들어주는 라이브러리도 많다.

한 가지 도구로 문서 타입 정의(DTD : Document Type Definition)를 들 수 있다. 이를 메타 마크업 언어로 생각할 수 있다. DTD는 XML처럼 보이는 문서이며(닫는 태그가 없다.), 마크업 언어 문법에 맞는 엘리멘트가 어떻게 생겼는지 정의할 수 있다. XML에는 XML 문서가 DTD를 가리킬 수 있게 허용하는 매커니즘이 있다. `<garden>` 엘리멘트 안에는 `<vegetable>` 엘리멘트가 1개 이상 있어야 하고 `<vegetable>`안에는 `<name>`, `<days>` 태그만 허용된다는 사실을 DTD로 기술할 수 있다. XML 파서는 XML 문서가 DTD를 준수하는지 검사할 수 있다. 이런 도구들도 유용하지만 이들이 가장 중요한 부분을 처리하는 것은 아니다. 예를 들어 DTD를 통해 필수적인 엘리멘트인 `<name>`이 XML 문서에 있는 지 검사할 수는 있지만, 다른 다양한 유형의 검증을 수행할 수는 없다. 

XML 경로 언어(Path, XML Path Language)는 XML 문서에 대한 셀렉터를 제공한다. XPath는 또 다른 호환 불가능한 문법을 사용한다. XPath는 기본적으로 CSS 셀렉터와 같은 기능을 하지만, 문법이 완전히 다르기 때문에 XPath를 따로 배워야 한다. XPath 자체는 그다지 우용하지 않지만 XPath는 확장 가능한 스타일 시트 언어 변환(XSLT : Xtensible Stylesheet Language Transformations)의 중요한 일부분이다.

XSLT는 XML에 바탕을 둔 또 다른 언어다. XPath와 XSLT를 결합하면 XML 문서를 표현한 파스트리를 검색하고 변형시킴으로써 XML 문서의 일부분을 다른 형태로 변환하는 XML 문서 조각을 작성할 수 있다. XPath 식을 사용해 정원에 있는 모든 채소를 매치시킨 다음에 이름과 각각의 품종을 공백으로 구분해 출력하는 예제다

```xml
<xsl :stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
	<xsl:template match="/garden/vegetable">
    	<xsl:value-of select="variety"/>
        <xsl:text></xsl:text>
        <xsl:value-of select="name"/>
    </xsl:template>
</xsl>
```

다음과 같은 결과가 나오게 된다.

```
variety name
variety name
variety name
```

또 다른 예제는 이름이 tomato인 채소만 선택해 처리한다. 

```xml
<xsl :stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
	<xsl:template match="/garden/vegetable[name/text()='tomato']">
    	<xsl:value-of select="variety"/>
        <xsl:text></xsl:text>
    </xsl:template>
    <xsl:template match="text()"/>
</xsl>
```

XSLT는 임의의 데이터가 들어 있는 마크업을 브라우저에 표현하기 위해 HTML로 변환하고 싶을 때 유용하다.





### 자바스크립트

현재까지 본 웹 페이지 예제는 정적(static)이다. 미리 어떻게 표시될 지 결정하는 텍스트를 그대로 표시만 했다. 웹 브라우저가 표시 중인 내용을 변경하는 유일한 방법은 새로운 URL을 웹 서버에 요청해서 문서를 받아오는 방법 뿐이다. 이 과정은 아주 느리고 자원도 낭비한다.   

1993년 마크 앤드리슨은 GUI를 제공하는 모자익(Mosaic) 웹 브라우저를 만들었고, 이 브라우저는 일반 소비자를 대상으로 하는 인터넷의 증가에 기름을 부었다. 그는 넷스케이프(Netscape)라는 회사를 창립하고 1994년 넷스케이프 내비게이터 브라우저를 출시했다. 더 대화형의 웹 페이지가 필요하다는 사실을 인식하고 넷스케이프에서는 1995년 자바스크립트(Javascript)라는 언어를 소개했다. 자바스크립트는 이우 에크마 인터내셔널(Ecma International)이라는 표준 위원회(에크마는 예전 유럽 컴퓨터 생산자 협회 European Computer Manufactures Association으로 알려져 있었고 1994년 현재 이름으로 변경되었다.)에 의해 ECMA-262로 표준화됐다. 그래서 자바스크립트가 에크마스크립트(ECMAscript)라고도 알려져 있고, EC라고도 부른다. 자바스크립트는 C언어와 자바에서 특성을 빌려왔고 자바는 다시 C에서 특성을 빌려왔다.

자바스크립트를 사용하면 서버가 아니라 (브라우저가 실행 중인) 컴퓨터에서 실행될 수 있는 실제 프로그램을 웹 페이지에 포함할 수 있다. 이 프로그램은 DOM을 변경하고 웹 서버와 통신할 수 있다.

```  
자바스크립트가 포함된 웹 브라우저와 웹 서버의 상호작용
    브라우저   -->
 |  ->       |           ->  |
DOM    자바스크립트 프로그램      서버
 |  <-       |           <-  |
            <--
```

자바스크립트 프로그램과 서버의 상호작용은 위에서 본 브라우저-서버 통신과 같지 않다. 자바스크립트와 서버의 상호작용은 비동기 자바스크립트와 XML(Asynchronous JavaScript and XML) 즉 AJAX를 통해 이뤄진다. 이 이름을 분석해 보면 '비동기'라는 말은 브라우저가 서버의 응답이 언제 일어날지에 대해(언제 응답이 돌아올지 돌아오지 않을 지에 대해) 아무 제어를 하지 않는다는 뜻이다. '자바스크립트'라는 말은 이 상호작용이 자바스크립트의 제어 하의 이뤄진다. 서버와 자바스크립트 프로그램 사이를 오가는 데이터 형식으로 처음에는 'XML'(HTML이 아닌)을 사용했다.

자바스크립트를 `<script>` 태그안에 넣어서 HTML 문서 안에 포함시킬 수 있다.

```html
<html>
    <script>
    	window.onload = () => {
            var big = document.getElemntsByTagName('big');
            big[0].style.background = 'green';
		}
    </script>
</html>
```

브라우저 명세에는 `window.onload` 라는 변수를 제공해야 한다는 규칙이 있다. 이 변수를 어떤 함수로 설정하면 브라우저가 페이지 문서를 읽어 들인 다음에 이 변수에 설정된 함수를 호출해준다. 브라우저 명세에는 DOM에서 태그 이름이 일치하는 모든 엘리멘트의 리스트를 돌려주는 `getElemntsByTagName`이라는 함수가 `document`라는 객체 안에 있어야 한다고 명시되어 있다. 그래서 `document.getElemntsByTagName('big')`을 호출하면 `<big>` 엘리멘트를 모두 얻을 수 있다. 여기서는 배경을 초록색으로 바꾼다.

DOM을 조작하는 함수가 많이 정의되어 있다. 이런 함수를 사용하면 단지 프로그램을 통해 CSS 스타일을 변경하는 작업 이상의 일을 할 수 있다. 그리고 DOM 트리 안의 노드를 재배치하는 함수들도 있다. 이런 함수 중에는 엘리멘트를 추가하거나 제거하는 등의 일을 할 수 있는 함수도 있다.





### jQuery

DOM 함수는 두 가지 문제가 있다. 첫째 DOM 함수 동작이 브라우저마다 다를 수 있다. 둘째 DOM 함수를 사용하기가 상당히 불편하다. DOM 함수는 그다지 사용자 친화적인(user-friendly) 인터페이스를 제공하지 않는다.

jQuery는 미국 엔지니어닌 존 레식이 2006년 만든 라이브러리이다. jQuery는 앞에서 나온 두 가지 문제를 해결한다. jQuery는 브라우저 사이의 불일치를 메워주기 때문에 jQuery를 사용하는 프로그래머가 직접 브라우저의 차이를 다룰 필요가 없고 훨씬 더 사용하기 쉬운 DOM 조작 인터페이스를 제공한다.

jQuery 라이브러리는 셀렉터와 액션(action)을 조합한다. 

```html
<html>
    <script type="text/javascript" src="http://code.jquery.com/jquery-3.2.1.min.js"></script>
    <script>
    	$(function() {
            $('big').css('background', 'green')
        })
    </script>
</html>
```

첫 번째 스크립트는 jQuery를 불러온다. 두 번째 스크립트는 실제 코드가 있다. `$('big')`은 셀렉터이다. 나머지 부분은 셀렉터로 선택한 원소에 대해 수행할 액션이다.

위 코드에 약간의 상호작용을 덧붙일 수 있다.

```js
$('big').click(function () {
    $('big').before('<i>Very</i>')
    $('big').css.('font-size', '500%')
})
```

위의 코드는 `<big>` 엘리멘트에 대해 마우스 클릭이 이뤄지면 실행될 이벤트 핸들러(event handler)를 연결한다. 핸들러는 `<big>` 엘리멘트 바로 앞에 `<i>Very</i>`를 추가하고 글꼴 크기를 바꾼다.

jQuery는 새로운 길을 개척했고 아주 널리 사용됐다. 하지만 다른 프로그래머들도 jQuery와 같은 일을 하짐나 서로 호환은 안 되는 경로를 개척하기 시작했다. 이제 같은 일을 하지만 서로 상이한 자바스크립트 라이브러리가 아주 많다.





### SVG

크기 변경이 가능한 벡터 그래픽스(SVG : Scalable Vector Graphics)는 브라우저가 지원하는 마크업 언어 중에 미운 오리 새끼 같은 것이라 할 수 있다. SVG는 멋진 그래픽과 텍스트를 만들 수 있도록 지원했지만 브라우저에서 사용 가능한 그 밖의 마크업 언어와는 완전히 다른 언어다.

존 워녹과 척 게스케는 1982년 어도비 시스템즈(Adobe Systems)를 설립했고 포스트스크립트(Postscript)를 만들었다. 워녹은 포스트스크립트의 개념을 더 복잡하게 만든 버전을 만들기 위해 수년간 작업했고 SGML이 너무 복잡해서 더 단순화한 HTML이 생긴 것과 같이 포스트스크립트 의 개발도 돌아가기 시작했다. 스티브잡스가 포스트스크립트를 애플 프린터에 사용하기 위한 드라이버를 개발해달라는 요청을 해서 존과 척은 잠깐 쉴수 있었다. 포스트스크립트 기반의 애플 레이저라이터는 데스크톱 퍼블리싱 산업 형성의 주 요인이었고, 어도비의 성공도 이에 힘입었다.

포스트스크립트는 이식성(portability), 어디서나 같은 결과를 갖지 못한다는 문제가 있었다. 이런 문제를 해결하기 위해 포스트스크립트에 기반한 이식 가능한 문서 형식(PDF : Portable Document Format)이 만들어졌다. SVG는 어느 정도 브라우저에 PDF를 욱여 넣은 것과 같다. SVG와 PDF는 전혀 호환성이 없다.

일반적으로 SVG는 캔버스(canvas)보다 더 자동이다. SVG로 무엇을 그릴지 지시하면 그대로 그림이 그려지지만 캔버스를 사용할 때는 캔버스를 조작하는 프로그램을 작성해야 한다. 다음을 살펴보라.

```html
<br>
<svg smlns="http://www.w3.org/2000/svg" width="400" height="400">
    <circle id="c" r="10" cx="200" fill="red"/>
	<animate xlink:href="#c" attributeName="r" from="10" to="200" dur="5s"/ >
</svg>
```





### HTML5

HTML5는 HTML의 최신 구현이다. 다른 기능과 더불어 HTML5에는  `<header>`, `<footer>`, `<section>`등 여러 시맨틱(semantic) 엘리멘트가 추가됐다. 이런 엘리멘트는 목적에 맞게 사용하면 문서의 구조의 일관성을 더해준다.

HTML5에는 캔버스(canvas)가 추가됐다. 캔버스는 SVG와 거의 비슷한 기능을 하지만 완전히 다른 방식으로 제공한다. SVG는 기존 DOM을 통해 조작하는 반면 캔버스는 캔버스를 위해 만들어진 새로운 자바스크립트 함수를 통해 조작해야 한다는 점이다. 원 애니메이션을 캔버스에 그대로 만들려면 자바스크립트 프로그램을 작성해야 한다.

HTML5에는 `<audio>`, `<video>` 엘리멘트도 추가됐다. 이들은 오디오와 비디오를 다루는 표준적인 매커니즘을 제공한다.





### JSON

간단히 AJAX를 다뤘을 때 브라우저 자바스크립트 프로그램은 서버에게 비동기로 XML 형식의 데이터를 보낸다고 했다. 하지만 이 말은 방금 전까지만 맞는 말이다. 이제 AJAX에서 X는 J로 바뀌어야 한다.

JSON은 자바스크립트 객체 표기법(Javascript Object Notation)을 줄인 말이다. JSON은 근본적으로 자바스크립트 객체(object)를 사람이 읽기 쉬운 방식으로 표현한 것이다. 이론적으로는 JSON 형식의 데이터는 서로 상호 운용이 가능해야 하지만, 실제로는 JSON 명세에 문제가 좀 있어서 몇몇 문자를 안 쓴다든지 하는 표준에 없는 몇 가지 규칙을 지켜야만 데이터 교환이 가능하다. 그리고  JSON이 모든 자바스크립트 데이터 타입을 지원하지는 않기 때문에 프로그래머가 가끔 이를 우회해야 할 때가 있다.

다음은 JS 객체를 만들고 JSON으로 변환한다. 그 후 JSON으로 변환한 결과를 `the_lang` 에 넣고 이 결과를 굵은 글꼴로 보여준다.

```js
var lang = {};
lang.goal = "make a product"
lang.langs = []
lang.langs[0] = {"name" : "python3"}
lang.langs[1] = {"name" : "js"}

var the_lang = JSON.stringify(lang)
```

```json
{
	"goal" : "make a product";
	"langs" : [
    	{"name" : "python3" },
		{"name" : "js"}
    ]	
}
```

자바스크립트 객체를 JSON 형식으로 손쉽게 바꿀 수 있다는 점 외에도 자바스크립트를 사용할 때 JSON이 XML보다 편리한 점이 있다. 자바스클비트의 `eval`함수는 데이터인 JSON을 마치 자바스크립트 프로그램 인 것처럼 실행할 수 있다. JSON을 사용하면 자바스크립트에서 데이터를 내보내고 들여올 때 추가로 코드를 작성할 필요가 없기 때문에 유명해졌다.

하지만 JSON을 쉽게 쓸 수 있다는 사실이 JSON을 다룰 때 아무 신경도 쓰지 않아도 된다는 뜻은 아니다. 분별없이 JSON 데이터를 다루면 `eval`로 임포트하면 공격자가 원하는 코드를 브라우저에서 실행할 수 있도록 허용할 수도 있다. 최근에는 JSON으 안전하게 자바스크립트 객체로 되돌릴 수 있는 `JSON.parse` 함수가 추가됐다.





### 정리

브라우저는 아주 복잡해 보인다. 브라우저에는 언어 파서, 파스 트리, 정규식, 인터프리터, 네트워크, 입력, 출력 등이 있다.

```
브라우저 블록도

                					통신 인터페이스
        |             												|
언어파서(HTML, XHTML, XML, SVG, CSS, Javascript)    <->       자바스크립트 라이브러리(Json, XML)
        |
문서 객체 모델 데이터                                                  ---|
        |
사용자 인터페이스 엔진(키보드, 포인터, 그림, 오디오, 비디오)                    ---|
```

이 구성도는 또 하드웨어와 소프트웨어 설계의 차이를 보여준다. 하드웨어 설계는 소프트웨어 설계보다 비용이 더 많이 든다. 하드웨어 설계자가 서로 호환되지 않는 방식으로 똑같은 일을 한느 여섯 가지 모듈로 이뤄진 시스템을 구성할 가능성은 없다. 하지만 소프트웨어에서 미리 지불해야 하는 비용은 하드웨어와 다르기 때문에, 소프트웨어 설계자들은 덜 조심하는 경우가 자주 있다. 처음에는 비용이 덜 들어서 더 크고 복잡한 시스템을 설계했는데, 나중에는 꼭 유지보수 해야하는 복잡하게 서로 상호 운용되는 부품 수가 늘어남에 따라 더 많은 비용이 들 수 있다.

이런 복잡한 인터프리터에 대해 배웠으므로 인터프리터에서 작동하는 프로그램을 작성해볼 때다. 이를 통해 몇 가지 중요한 시스템 수준의 고려사항을 보여줄 것이다. 이런 사항은 웹 프로그래머에게는 감춰져 있지만 시스템 수준에서 프로그래밍을 하는 프로그래머에게는 중요하다.

## 병렬성과 비동기성

> 컴퓨터는 어떻게 한 번에 많은 일을 하는가



멀티태스킹(multitasking) 한 번에 둘 이상의 작업을 수행하는 것에 대해 이야기 한다. 원래는 CPU가 하나여서 그냥 여러 작업을 동시에 수행할 수 있는 척을 했지만 이제는 멀티코어 프로세서가 대세이고 실제 컴퓨터는 한 번에 둘 이상의 일을 하고 있다. 멀티프로세싱은 특별히 새로운 개념이 아니다. 오랜 시간 동안 더 높은 성능을 얻기 위해 단일 코어 프로세서를 서로 연결하곤 했다. 단지 요즘은 여러 프로세서를 연결하기가 쉽고 멀티프로세서를 더 일반적으로 사용한다.  이제 더 이상 멀티프로세서 시스템이 값비싼 특별한 용도의 기계가 아니다. 

때로 처리 순서가 중요한 경우가 있다. 예를 들어 잔고가 100만원인 예금이 있을 때 75만원을 출금할 때 동시에 다른 사람이 50만원을 찾으려고 한다. 이런 경우를 경합 조건(race condition)이라고 하고 은행 소프트웨어는 공동 계좌를 잠가서 둘 중 한 사람에게만 지급해야 초과 인출을 막을 수 있다. 이 말은 일부 연산에 대해서는 근본적으로 멀티태스킹을 막아야 한다는 뜻이다. 하지만 멀티태스킹의 이점을 잃지 않고 경합 조건을 해결하고 락을 사용하기는 어렵다.





### 경합 조건이란 무엇인가

경합 조건은 2개의 프로그램이 같은 자원에 동시에 접근하고 자원 사용 순서에 따라 결과가 달라지는 경우를 뜻한다. 두 프로그램이 계좌에 돈을 입금하는 경우를 보라

```
경합 조건 예제

      올바른 예시                            잘못된 예시
프로그램 1 프로그램 2  잔고             프로그램 1 프로그램 2 잔고
100만원            100              =100             100
+10만원            100               +10             100
=110만원           110                        =100   100
         =110     110                         +50   100
         +50      110               =110            110
         = 160    160                        =150   150
```

이 예제에서 공유자원 (shared resource)은 계좌 잔고다. 결과가 두 프로그램이 공유자원에 접근하는 타이밍에 따라 결과가 다르다는 것을 알 수 있다.





### 공유자원

거의 대부분의 자원이 공유될 수 있다. 메모리는 항상 공유 문제와 연관이 되는데 심지어는 공유 대상이 메모리가 아닌 경우에도 메모리가 관련된 경우가 많다. 공유 자원이 사용 중인지 표현할 방법이 필요하기 때문이다. 이런 메모리는 우리가 메모리라고 생각하는 전형적인 메모리가 아닐 수도 있다. 입출력 장치 하드웨어에 있는 어떤 비트일 수도 있다.

I/O 장치를 공유하는 경우는 아주 흔하다. 프린터를 생각해 볼때 여러 문서가 뒤섞인다면 공유 프린터가 제대로 작동하지 않을 것이다. 운영체제가 사용자 프로그램 대신 I/O를 처리한다. 이런 설명은 USB 컨트롤러처럼 운영체제가 실행 중인 기계에 속한 I/O 장치의 경우에만 성립한다. 운영체제는 USB에 연결된 장치와 사용자 프로그램이 제대로 통신하는 것을 보장하는 반면, 어떤 장치에 대한 제어는 그냥 사용자 프로그램에게 넘겨버리는 경우도 자주 있다.

FPGA가 새로운 공유 대상 자원으로 떠오르고 있다. FPGA를 프로그래밍해서 소프트웨어의 특정 부분을 빨리 실행하는 하드웨어 기능을 제공하고 싶을 수 있다. 이런 경우 소프트웨어가 사용할 FPGA 프로그램을 다른 사람이 변경하는 것을 원하지 않을 것이다. 다른 컴퓨터 상에서 실행되는 프로그램이 서로 통신하는 경우에도 공유 자원을 가질 수 있다는 점은 약간 덜 분명해 보이지만 이런 경우도 공유 자원이 있을 수 있다.





### 프로세스와 스레드

운영체제의 기능은 여러 작업을 관리하는 것이다.

운영체제는 프로세스(process)를 관리한다. 프로세스는 사용자 공간(user space)에서 실행되는 프로그램이다. 멀티코어 시스템에서는 여러 프로그램이 병렬(실제로 2개 이상의 프로그램이 동시에 실행되는 것)로 실행될 수 있다. 여러 프로그램이 병렬로 실행된다는 것만으로는 경합 조건이 발생하지 않는다. 병렬로 실행되는 프로그램이 자원을 공유해야 경합 조건이 발생할 수 있다.

자원을 공유하는 프로세스는 어떤 방식으로든 서로 통신을 해야 한다는 뜻이다. 이 통신은 여러 가지 형태로 일어날 수 있다. 통신 방식은 프로그램에 코드 형태로 들어가거나, 어떤 설정 정보를 통해 정해져야 한다.

때론 프로세스가 여러 가지 일에 신경을 써야 할 수 있다. 프린트 서버(print server)가 좋은 예다. 프린트 서버는 프린터 문서 출력을 처리하는 동시에 다른 프로그램이 자신에게 통신하는 것도 신경 써야 한다. 네트워크가 생기기 전에는 출력할 프린터가 I/O 포트에 연결된 기계가 아닌 경우 프린터를 사용하기 어려웠다. 1980년대 버클리 캘리포니아 주립 대학교에서 몇 가지 시스템 콜을 추가함으로써 더 쉽게 컴퓨터끼리 통신이 가능하게 해주는 네트워크 관련 코드가 개발됐다. 핵심은 프로그램이 여러 곳에서 들어오는 액티비티를 기다리며 대기하다가, 들어온 액티비티에 따라 적절한 핸들러를 호출할 수 있게 됐다는 점이다. 이런 접근 방법은 아주 잘 작동했다. 잘 작동한 주된 이유는 핸들러 코드가 꽤 간단해서 다음 액티비티가 들어오기 전에 처리를 끝낼 수 있기 때문이다. 프린트 서버는 다음 문서 도착을 걱정할 필요 없이 전체 문서를 출력할 수 있었다.

GUI를 통한 대화식 프로그램으로 인해 이 모든 상황이 달라졌다. 액티비티 핸들러는 더 이상 처음부터 끝까지 한 번에 실행이 끝나는 간단한 작업이 아니게 됐다. 액티비티 핸들러가 중간에 사용자 입력을 기다리느라 대기해야 하는 경우가 많이 생겼다. 서로 협력하는 프로세스들의 집단으로 프로그램을 작성할 수도 있지만 여러 프로세스가 상당히 많은 데이터를 서로 공유해야 하기 때문에 이런 식의 코딩은 꽤 성가시다.

필요한 것은 핸들러를 인터럽트할 수 있게 만드는 것이다. 이 말은 핸들러가 실행하는 중간에 잠시 실행을 중단하면서 상태를 저장하고, 나중에 그 위치로 돌아와 실행을 재개할 수 있다는 뜻이다. 저장할 상태는 스택에 존재한다. 문제는 프로세스마다 스택이 하나뿐이다. 하지만 이 경우에는 프로세스에 속한 모든 핸들러가 각각 따로 스택을 가져야 하는 것처럼 보인다. 실행 스레드를 생각해보자. 스레드(thread)는 정적인 데이터와 힙을 공유하지만 자체적으로 스택을 갖는 프로그램의 일부분을 말한다. 각 스레드는 자신이 CPU 레지스터를 완전히 소유한다고 가정한다. 따라서 한 스레드에서 다른 스레드로 실행이 넘어갈 때는 스레드 스케줄러(thread scheduler)가 CPU 레지스터를 저장해야 한다. 이는 운영체제가 프로세스에서 다른 프로세스로 문맥을 전환할 때 일어나는 일과 비슷하다. 스레드는 일반 프로세스보다 저장할 컨텍스트 크기가 훨씬 작기 때문에 프로세스 문맥 전환보다 스레드 문맥 전환이 더 빠르다. 그래서 스레드를 다른 말로 경량 프로세스(lightweight process)라고 부르기도 한다.

```
스레드를 사용하는 경우의 메모리 배치

스레드 1 스택
     |
스레드 2 스택
     |
스레드 n 스택
     |
     힙
 정적 데이터
```

초기의 스레드 구현은 기계에 따라 다르게 정의된 어셈블리 언어 코드를 포함했다. 스레드가 충분히 유용하다는 사실이 입증된 다음부터는 기계와 독립적인 API가 표준화됐다. 스레드를 사용하면 한 프로세스 안에서 경합 조건을 만들 수 있기 때문에 흥미롭다. 스레드를 사용하면 경합 조건이 생길 수 있는 문제는 C만의 문제는 아니다. 자바 스크립트 이벤트 핸들러도 스레드다.(하지만 윈도우당 하나의 자바스크립트 스레드만 사용되며 이것이 C에서 스레드 API를 사용해 스레드를 만들었을 때와 다르다.)

하지만 스레드가 존재한다고 해서 어떤 경우든 스레드가 올바른 해법이라는 뜻은 아니다. 스레드를 남용하면 나쁜 사용자 경혐을 야기할 수 있다. 마이크로소프트가 처음 윈도우1.0을 출시했을 때 윈도우는 MS-DOS 상에서 돌아가는 일반 프로그램이였다. MS-DOS는 멀티태스킹을 지원하는 최신 운영체제가 아니였다. 그 결과 마이크로소프트는 운영체제의 일부분을 애플리케이션에 넣어서 사용자가 여러 문서를 여는 등의 작업을 지원했다. 불행히도 사람들이 이 접근 방법을 제대로 된 운영체제에서 실행되는 프로그램에도 도입했다. 그래서 이런 방식이 탭을 사용하는 애플리케이션(파이어폭스)나 사용자 인터페이스(그놈)에도 나타났다.

이런 아이디어가 나쁜 이유는 스레드가 데이터를 공유하기 때문이다. 따라서 보안 문제가 생긴다. 둘째로 한 탭에서 문제가 생기거나 버그가 발생하면 전체 프로세스가 멈춘다. 그래서 문제가 생긴 부분과 무관한 부분의 내용을 잃어버릴 수 있다. 세번째는 어떤 스레드가 작업이 너무 오래 걸리면 다른 모든 스레드가 실행되지 못해서 문제가 발생할 수 있다. 예를 들어 어떤 웹 페이지 로딩이 느려지면 여러 브라우저 탭이 멈춰버릴 수 있다.

여기에서 생각해야 하는 것은 운영체제를 잘 활용해야 한다는 것이다. 운영체제가 제대로 작동하지 않거나 필수적인 기능을 제공하지 않는다면 그 문제를 수정해라. 다른 나머지를 망치지 마라.





### 락

우리가 실제적으로 처리해야할 문제는 여러 작은 연산으로 이뤄진 작업을 어떻게 원자적으로 만들 수 있을 까 하는 문제다.(어떻게 나눌 수 없고 인터럽트 할 수 없게 만들 수 있을까?)

컴퓨터에 '은행 잔고를 조정하라.'라는 명령어는 없다. 이런 명령어를 만들기 위해 매우 많은 명령어가 필요하다. 대신에 코드에서 중요한 부분을 상호 배제(mutual exclusion) 매커니즘을 통해 원자적으로 처리하게 만들어야 한다. 이런 목표를 프로그램이 충돌을 피하기 위해 따르는 어드바이저리 락(advisory lock)을 만들어서 달성한다.

```
어드바이저리 락

잔고 잠금 -> 100만원 읽음 -> 10만원 더함 -> 110만원 씀 -> 잔고 잠금 해제 -> 잔고 잠금(잠금 실패 시 계속 시도) ->
110만원 읽음 -> 50만원 더함 -> 160만원 씀 -> 잔고 잠금 해제
```

위쪽 프로그램이 락을 먼저 얻었다. 따라서 아래쪽 프로그램은 락이 해제될 때까지 기다려야 한다. 락이 어브바이저리(조언을 해주는 사람)인 이유는 락을 지킬지 안 지킬지를 프로그램이 결정하기 때문이다. 강제로 락을 지키게 하는 장치는 없다. 강제성이 없으면 은행털이를 막을 수 없으므로 쓸모가 없어 보인다. 하지만 이는 락이 어디에 위치하느냐에 따라 크게 달라진다. 다음과 같이 락이 은행을 지킨다면 강제로 은행을 잠글 수 있게 되고 제대로 작동한다.

```
락 위치

프로그램 #1
             락 | 은행
프로그램 #2
```

이렇게 하면 한 가지 문제는 해결되지만 다른 문제가 생긴다. 프로그램 #1과 은행 사이의 통신이 느리다면 어떤 일이 벌어질까? 분명 프로그램 #2가 기다려야 하므로 멀티태스킹의 장점을 일부 잃어버리게 된다. 게다가 프로그램 #1이 죽어버리거나 악의적으로 동작해서 락을 결코 반환하지 않으면 프로그램 #2는 대기하는 동안 무엇을 해야 할까?

* 트랜잭션과 작업 크기

  프로그램 #1이 수행하는 모든 연산에서 은행과 통신할 필요가 있다. 다음 연산을 수행하기 전에 앞의 연산이 성공했는지 알아야 하기 때문에 각 연산은 양방향 통신 이여야 한다. 성능을 향상할 가장 좋은 방법은 여러 연산을 한 트랜잭션(transaction)에 넣는 것이다. 트랜잭션에 들어있는 모든 연산은 모두 다 사용하거나 모두 다 실패한다.

  ```
  트랜잭션
  
  트랜잭션
  잔고잠금 - 100만원 읽음 - 10만원 더함 - 110만원 씀 - 잔고 잠금 해제
  
  트랜잭션
  잔고잠금 - 110만원 읽음 - 50만원 더함 - 160만원 씀 - 잔고 잠금 해제
  ```

  트랜잭션이라는 말은 데이터베이스에서 왔다. 각 연산을 독립적으로 수행하는 대신 한꺼번에 묶어서 처리한다.

  분명한 가이드라인은 어떤 대상을 잠그는 시간을 최소화하라는 것이다. 락이 걸려 있는 시간이 길면 동시성이 줄어들기 때문이다. 그리 분명해 보이지 않는 가이드라인으로는 락이 걸린 작업의 크기(granularity)를 최소화하라는 것이다. 작업 크기라는 말은 락이 잠그고 있는 영역의 크기를 뜻한다. 한 계좌의 잔고만 잠근다는 사실을 암시적으로 알 수 있다. 고객이 잔고를 변경할 때마다 전체 은행을 잠근다면 좋은 해법이 아닐 것이다. 

  시스템에서 아주 작은 부분만 잠그는 락을 세밀하다(fine grained)라고 한다. 더 큰 범위를 잠그는 락을 성기다(coarse-grained)라고 한다.

* 락 대기

  프로그램이 락을 기다리는 동안 그 어떤 유용한 일도 할 수 없다면 락을 세밀하게 만들어도 아무 이득이 없다. 결국에는 다중성이라는 말을 멀티태스킹 전체 측면에서 살펴봐야 한다.

  때로는 락을 기다리는 동안 수행할 유용한 작업이 없는 경우도 종종 있다. 그래서 응답을 기다릴 경우가 있다. 하지만 우리는 스핀(spin)을 돌 수 있다. 락을 성공적으로 얻을 때까지 락 획득을 반복 시도 한다는 뜻이다. 스핀을 사용할 때는 시도 간격을 조정하기 위해 타이머를 사용하는 경우도 자주 있다. 기계에서 전속력으로 스핀을 돌면서 락을 체크하면 전력을 불필요하게 많이 소모한다. 환경에 따라서는 락을 관리하는 쪽에 등록(register)하고 요청이 받아들여졌을 때 통지(notify)를 받는 수도 있다. 이 방식을 택하면 요청하는 쪽에서는 기다리는 동안 더 유용한 일을 할 수 있다. 이런 접근 방법은 규모를 쉽게 키우기 어렵고 인터넷 아키텍처에서는 직접적으로 지원되지 않는다. 대신 필요하면 인터넷 위에 이런 방식을 구현할 수는 있다.

  이더넷은 락을 사용하지 않지만 여러 장치가 공유 자원에 동시에 접근하려고 시도해서 충돌하는 경우 임의의 시간을 가지고 재시도한다.

  일부 운영체제는 락 기능을 제공하는데 이 핸들은 보통 파일 디스크립터와 비슷한 핸들과 연관된다. 블로킹이나 비블로킹 모드로 락을 요청할 수 있다. 블로킹(blocking)이라는 말은 시스템이 락을 할당할 수 있을 때까지 락을 요청한 프로그램을 일시 중단(suspend)시킨다는 뜻이다. 논블로킹(non-blocking)이라는 말은 프로그램이 계속 실행되고 나중에 락을 얻었는지 여부를 어떤 방식으로든 통지받게된다는 뜻이다.

* 교착 상태

  프로그램이 락을 얻을 수 없으면 락이 사용 가능해질 때까지 어떤 식으로든 기다려야 한다. 하지만 복잡한 시스템에서는 여러 락을 사용하는 경우도 있다.

  ```
  교착 상태
  
  프로그램 #1 프로그램 #2
  락 A를 획득 락 B를 획득
  락 B를 획득 락 A를 획득
  락 A를 해제 락 B를 해제
  ```

  프로그램 #1은 성공적으로 락 A를 얻고, 프로그램 #2는 성공적으로 락 B를 얻는다. 다음으로 프로그램 #1은 락 B를 얻으려 시도하지만 

  
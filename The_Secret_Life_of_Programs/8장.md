## 프로그래밍 언어 처리

> 컴퓨터는 프로그램을 어떻게 해석하고 변환하는가



프로그래밍 언어(programming language)로 인해 적어도 프로그램 작성이 훨씬 쉬워지기는 했다.

이번에는 프로그래밍 언어가 어떻게 구현되었는지 살펴본다. 그리고 작성한 코드가 기계어(machine language)로 어떻게 변환되는 지 살핀다.





### 어셈블리 언어

프로그램의 각 명령어에 대한 비트 조합을 하나하나 알아내려면 아주 고통스럽다. 초기 프로그래머들은 이 과정에 신물이 나서 프로그램을 작성하는 더 나은 방법을 고안해냈다. 이 방법이 어셈블리 언어(assembly language)이다.

어셈블리 언어는 다음과 같은 놀라운 일을 해준다. 어셈블리 언어를 쓰면 프로그래머가 모든 비트 조합을 외우지 않아도 이해하기 쉬운 니모닉(mnemonics)을 통해 명령어를 쓸 수 있다. 어셈블리 언어에서는 주소에 이름, 즉 레이블(label)을 붙일 수 있다. 그리고 주석을 달아서 프로그램의 이해를 도울 수 있다.

어셈블리 언어로 작성된 코드를 읽어서 동등한 기계어 코드(machine code)를 생성해주는 프로그램을 어셈블러(assembler)라고 한다. 이런 변환 과정에서 어셈블러는 레이블이나 심볼(symbol)의 값을 결정해 채워 넣어준다. 코드에서 명령어 위치가 바뀌면 생길 수 있는 바보 같은 오류를 예방해주기 때문에 심볼의 값을 결정해 넣어주는 기능은 아주 유용하다. 다음 리스트는 피보나치 프로그램을 가상의 어셈블리 언어로 작성한 코드다.

```
again load #0 ; first를 0으로 설정
      store first
      load #1 ; second를 1로 설정
      store second
      load first ; first와 second를 더해서
      add second ; next를 계산
      store next
                 ; 계산한 수를 가지고
      laod second ; second를 first로 옮김
      store first
      load next ; next를 second로 옮김
      store second
      cmp #200 ; 다 끝났는가?
      ble again ; 끝나지 않았다면 again다시 시작
first bss 1 ; first가 저장될 위치
second bss 1 ; second가 저장될 위치
next bss 1 ; next가 저장될 위치
```

bss(block started by symbol)라는 의사명령어(pseudo-instruction)는 메모리 덩어리를 예약하되 메모리 안에는 아무 값도 넣지 않는다. 의사명령어는 기계어와 직접 대응되지는 않지만 어셈블러에게 지시를 내린다.

초창기 프로그래머는 불가능한 일을 해야 했다. 초창기 컴퓨터가 만들어졌을 때는 어셈블러도 없었다. 그래서 개발자들은 어려운 방식, 즉 직접 손으로 모든 비트를 알아내는 방법으로 최초의 어셈블러를 작성해야 했다. 첫 번째 어셈블러는 원시적이였지만 제대로 작동하는 어셈블러가 생겼기 때문에 이 어셈블러에서 작동하는 어셈블리 언어를 사용해 더 나은(더 많은 의사명령어와 기능을 제공하는) 어셈블러를 어셈블리 언어로 작성할 수 있었고 개선된 의사명령어로와 기능을 활용하는 어셈블리 언어로 다시 더 많은 기능을 제공하는 개선을 계속할 수 있었다.

부트스트랩(bootstrap)이라는 말이 그래서 생겨냈다. 이 말은 부트(boot)로 줄여서 부르기도 한다. 컴퓨터를 부팅하는 과정은 롬 등에 들어있는 작은 프로그램을 메모리로 읽어오는 것부터 시작한다. 이 프로그램은 필요한 초기화를 진행한 뒤 더 큰 프로그램을 SSD 혹은 USB에서 읽어오고 이 프로그램은 더 큰 운영체제 등을 불러올 수 있다. 초기 컴퓨터에서는 사람이 직접 전면 패널의 스위치를 사용해 최초 부트스트랩 프로그램을 입력해야만 했다. 





### 고수준 언어

어셈블리 언어는 큰 도움이 됐지만 간단한 일을 할 때도 많은 작업이 필요하다. 더 적은 작업을 위해 프레드 브룩스는 채겡서 평균적으로 하루에 3~10줄의 문서화되고 디버깅이 이뤄진 코드를 작성한다고 주장했다. 따라서 코드 한 줄로 더 많은 일을 할 수 있다면 훨씬 더 많은 일을 완수할 수 있다. 

고수준 언어(high level language)로 들어가자. 고수준 언어는 어셈블리 언어보다 더 높은 추상화 단계에서 작동한다. 고수준 언어의 소스 코드는 컴파일러라는 프로그램에 의해 실행된다. 고수준 언어의 소스 코드는 컴파일러(compiler)라는 프로그램에 의해 실해오딘다. 컴파일러는 소스 코드를 기계어로 번역, 즉 컴파일(compile)해준다. 기계어 코드를 다른 말로 목적 코드(object code)라고 한다. 

많은 고수준 언어가 생겨났다. 처음 생긴 고수준 언어에는 포트란(FORTRAN)이 있다. 포트란이라는 이름은 식 변환기(formula translator)를 줄인 말이다. 포트란을 사용하면 `y  = m * x + b`같은 수식을 계산하는 프로그램을 쉽게 작성할 수 있다. 포트란으로 피보나치 수열을 작성한 모습이다.

```fortran
C로 시작하는 문장은 주석
C 초기 수열의 두 수 I와 J를 0과 1로 설정
  I = 0
  J = 1
C 수열의 다음 수를 구함
  K = I + J
  I = J
  J = K
C 마지막 수가 200보다 작으면 루프를 반복 수행
  IF (J .LT .200) GOTO 5
C 끝
```

어셈블러보다 더 단순하다. 레이블이 있는데 모두 숫자여야 한다. 또한 명시적으로 사용하려는 메모리를 선언할 필요는 없다. I나 J 같은 변수(variable)를 사용하면 메모리가 할당된다. 포트란은 몇 가지 흥미로운 시도를 했는데 오늘날 까지 잔재로 남아있다. 이름이 I,J,K로 시작하는 변수는 정수다. 다른 글자로 시작하는 변수는 부동소수점 수 또는 REAL이다.

포트란은 당시 큰 기계에서만 실행되던 언어였다. 더 작고 값싼 기계가 등장하면서 다른 언어가 만들어 졌다. 베이직(BASIC : Beginner's All purpose Symbolic Instruction Code)(초보자를 위한 범용 기호적 명령어 코드)을 비롯한 상당수는 포트란의 아이디어를 받아들여 변형한 언어였다. 이런 언어에는 똑같은 문제가 있었는 데 프로그램이 복잡해지면서 GOTO로 이뤄진 연결이 관리할 수 없을 정도로 너무 복잡해졌다. 프로그램을 작성할 때 처음에는 레이블 번호를 순서대로 작성했지만 코드를 변경하다보면 금방 순서가 뒤섞이고 레이블의 위치를 찾기가 어려워졌다. 나중에 레이블을 끼워 넣을 수 있게 레이블 번호를 10이나 100정도 떨어뜨리면서 여유를 가지는 프로그래머도 많았다. 하지만 이런 방법이 항상 통하지는 않았다.





### 구조적 프로그래밍

포트란이나 베이직 언어는 비구조적(unstructured) 언어라고 불린다. GOTO와 레이블을 조합할 때 아무런 구조를 강요하지 않기 때문이다. 포트란에서는 원하는 대로 GOTO와 레이블을 사용해 프로그램을 작성할 수 있었다. 여기서 말하는 포트란은 맨 처음 나온 포트란을 뜻한다. 포트란도 계속 진화해 왔고 진화 과정에서 구조적 프로그램 개념을 포함시켜왔다. 

구조적(structured) 프로그래밍은 이런 잘못된 GOTO 사용으로 인해 발생할 수 있는 스파게티 코드(spaghetti code) 문제를 해결하기 위해 개발됐다. 몇몇 언어는 구조적 프로그래밍 개념을 극단까지 수용했다. 파스칼은 GOTO를 완전히 없앴고 이로 인해 기초적인 구조적 프로그래밍을 가리칠 때만 유용한 프로그래밍 언어가 됐다. C는 켐 톰슨이 만든 B언어를 계승한 언어인데, 원래 벨 전화 연구소의 데니스 리치에 의해 만들어 졌다. C는 아주 실용적인 언어이며 가장 널리 쓰이는 프로그래밍 언어 중 하나가 됐다. 나중에 나온 언어 중 상당수가 C의 요소를 그대로 가져다 썼으며  그와 유사한 언어로는 C++, 자바, PHP, 파이썬, js등이 있다.

js로 작성한 피보나치 프로그램이 있을 때 명시적인 분기(GOTO)가 없다는 점을 알 수 있다.

```js
var first = 0
var second = 1
var next = first + second
while (next < 200) {
    first = second
    second = next
    next = first+second
}
```

while문이 항상 참일 경우 문장이 반복 실행되며 제어 흐름이 깔끔하기 때문에 프로그램을 더 쉽게 이해할 수 있다.





### 어휘 분석

이제 언어를 어떤 식으로 처리하는지 알아보자. 먼저 어휘 분석(lexical analysis)부터 살펴보자. 어휘 분석은 코드를 기호(문자들)로부터 단어와 같은 성격의 토큰(token)으로 변환하는 과정이다. 

어휘 분석을 간단히 살펴보기 위해 단어와 구분자(separator)라는 두 가지 유형의 토큰만 존재하는 언어를 가정하자. 이런 규칙의 언어에서 'lex luthor'(모든 나쁜 프로그래밍 언어를 만든 사람)는 2개의 토큰(lex, luthor)과 1개의 공백으로 구분된다. 입력을 토큰들로 분리하는 간단한 알고리즘을 보여준다.

```
시작 -> 토큰 버퍼를 지움 -> 문자를 얻어옴 -> 구분자인가? -yes> 토큰 버퍼가 비었는가? -no> 문자를 얻어옴 
                                     |                |-yes> 토큰 버퍼에서 토큰을 만듬 -> 토큰 버퍼를 비움
                                     no> 토큰 버퍼 끝에 문자를 추가 -> 문자를 얻어옴
```

토큰을 추출하는 것만으로는 충분하지 않다. 실용적인 언어라면 이름, 숫자, 연산자 등 토큰 유형도 많기 때문에 토큰을 구분해야 한다. 언어에는 수학에서와 마찬가지로 보통 연산자와 피연산자가 있고, 피연산자로는 변수와 상수(숫자)가 있을 수 있다. 여러 언어가 제공하는 자유로운 형식으로 인해 좀 더 문제가 복잡해진다. 예를 들어 A+B와 A + B처럼 구분자가 없지만 암시적으로 있는 것처럼 처리하려면 문제가 더 복잡해진다. 두 형태 모두 해석은 같지만 첫 번째 형태에는 명시적인 구분자가 없다.

수를 표현하는 상수도 제대로 구분하려면 놀라울 정도로 어렵다. 8진수, 16진수, 정수, 부동소수점 수의 구분을 무시하더라도 그렇다. 또한 부동 소수점을 표시하기 위해서는 배커스 나우르 표기법처럼 더 형식적으로 정의된 방법도 있다.

* 상태 기계

  수의 복잡성만 살펴봐도 입력에서 언어 토큰을 추출하는 특별한 코드의 분량이 얼마나 많을 지 상상할 수 있다. 또 다른 접근 방법의 힌트를 상태로 이뤄진 집합과 한 상태에서 다른 상태로 전이되는 원인의 목록으로 이뤄진 상태 기계(state machine)를 만들 수 있다.

  ```
  입력       상태 (e는 에러 c는 완료)
  0    1 2 3 4 5 6 7
  1    3 3 3 4 7 7 7
  2    3 3 3 4 7 7 7
  3    3 3 3 4 7 7 7
  4    3 3 3 4 7 7 7
  5    3 3 3 4 7 7 7
  6    3 3 3 4 7 7 7    
  7    3 3 3 4 7 7 7
  8    3 3 3 4 7 7 7
  9    3 3 3 4 7 7 7
  0    3 3 3 4 7 7 7
  e    e e 5 5 e e e
  E    e e 5 5 e e e
  +    2 e c c 6 e c
  -    2 e c c 6 e c
  .    4 4 4 c e e c
  기타  e e e e e e e
  ```

  상태 1에 있을 때 숫자가 오면 상태 3으로 가고, e나 E가 오면 상태 5로 가며, +,-가 오면 상태 2, .이 오면 상태 4로 간다는 사실을 알 수 있다. 그리고 그 외의 문자가오면 모두 오류다.

  상태 기계를 사용하면 다음 처럼 간단한 코드를 통해 입력을 분류할 수 있다. 표를 사용하되 완료는 0으로 오류는 -1의 상태로 표시한다.

  ```c
  // 상태 기계 사용하기
  state = 1;
  while (state > 0)
  	state = state_table[state][next_character];
  ```

  다른 유형의 토큰에 대해서도 이 접근 방법을 쉽게 확장할 수 있다. 완료라는 한 가지 값만 부여하는 대신, 각 토큰 유형에 따라 각기 다른 완료 상탯값을 부여하면 된다.

  

* 정규식

  테이블을 만드는 과정은 아주 지루하고, 언어가 복잡하면 실수를 저지르기도 쉽다. 해법은 언어를 지정하기 위한 언어를 정의하는 것이다. 미국 수작자 스티븐 콜 클레이니는 1956년 이미 이런 접근 방법에 대한 수학적 기초를 놓았다. 켄 톰슨은 1968년 텍스트 편집기의 일부분으로 이를 소프트웨어로 변환했고 그 후 유닉스 grep 유틸리티 명령을 만들었다.(grep은 정규식을 전역으로 찾아서 출력하라라는 뜻의 영어 globally search a regular expression and print의 약자이다.) 이 명령으로 인해 정규식(regular expression)이라는 말이 널리 알려졌고, 이제는 정규식을 거의 대부분의 프로그래밍 언어에서 사용한다. 정규식 자체도 언어이기 때문에, 현재는 서로 호환이 되지 않는 몇 가지 정규식 언어가 존재한다. 정규식은 패턴 매칭(pattern matching)에서 중추적 역할을 한다. 

  ```
  [+-]?(([0-9]*\.?[0-9]+) | ([0-9]+\.?[0-9]*)) ([Ee][+-]?[0-9]+)?
  [+-] : + or -
  ? : 바로 앞의 부호가 0번 또는 1번 나타남
  [0-9] : 0~9까지의 숫자
  * : 바로 앞의 0-9를 0번 이상 반복
  \ : 바로 다음에 오는 문자의 특별한 의미를 없앰
  . : 소수점
  + : 바로 앞의 0~9를 1번 이상 반복
  ```

  정규식은 횡설수설 처럼 보이겠지만 몇가지 간단한 규칙에 의해서만 의존한다. 정규식은 왼쪽에서 오른쪽으로 처리된다. 이 말은 "abc"라는 문자열은 "abc"와 매치된다는 뜻이다. 

  ?는 패턴 이 0번 또는 1번 나타난다는 뜻이고, 

  *는 패턴이 0번 이상, 

  +는 1번 이상 나타난다는 뜻이다. 

  각괄호로 둘러싸인 문자 집합은 그 집합 안에 있는 어느 한 문자와 매치된다는 뜻이다. 따라서 [abc]는 a, b, c중 하나와 매치될 수 있다.

  .은 아무 글자든 한 글자와 매치될 수 있다. .이라는 글자 자체와 매치하려면 백슬래시를 통해 .의 특별한 기능을 이스케이프(escape)해야 한다.

  |는 이 기호의 왼쪽이나 오른쪽에 있는 패턴 중 하나와 매치되면 된다는 뜻이다.

  괄호 ()은 수학과 마찬가지로 정규식을 그룹으로 묶을 때 쓰인다.

  앞의 부동소수점 정규식을 왼쪽에서 오른쪽으로 읽으면 처음에는 선택적인 양수나 음수 부호를 만난다.  그 뒤에 괄호로 묶은 그룹이 온다. 그룹 안에는 두 가지 패턴이 |로 연결되어 있다. 첫 번째 패턴은 0글자 이상의 숫자가 오고, 선택적인 소수점이 오며 그 뒤에 1개 이상의 숫자가 온다. 두 번째 패턴은 1글자 이상의 숫자가 오고 선택적인 소수점이 오며, 0 글자 이상의 숫자가 오는 패턴이다. 그 뒤에 선택적 지수 패턴이 온다. E나 e중 하나가 오고 그 뒤에 부호가 오며 숫자가 1개 이상 있어야 한다.

  입력을 토큰으로 처리할 수 있는 정규식 언어가 있고, 이로부터 자동으로 상태 테이블을 만들어 낼 수 있으면 훨씬 더 유용할 것이다. 그리고 벨 연구소 덕에 그런 도구가 이미 있다. 1975년 미국 물리학자 마이크 레스크는 인턴이였던 에릭 슈미트와 함께 lex라는 프로그램을 만들었다. lex는 어휘 분석기(lexical analyzer)를 줄인 말이다. 나중에 GNU 프로젝트에서는 오픈소스 버전인 flex를 만들었다. 이런 도구들이 정확히 우리가 원하는 일을 해준다. 이득은 입력이 정규식과 매치될 때 사용자가 제공한 프로그램 조각을 실행해주는 상태 테이블 기반의 프로그램을 생성해준다.

  다음 프로그램은 입력에서 ar이나 er을 만날 때마다 ah를 출력하고 단어가 a로 끝날 때마다 er를 출력해준다.

  ```lex
  [ae]r printf("ah");
  a/[ .,;!?] printf("er");
  ```

  두 번째 패턴에서 /는 /의 왼쪽에 있는 패턴에 매치시키되 /의 오른쪽에 있는 패턴이 뒤에 올 때만 매치시키라는 뜻이다. 

  토큰을 분류하는 작업은 lex가 있으면 쉽다. 모든 형태의 수와 변수 이름, 몇 가지 연산자와 매치되는 lex 프로그램이다. 발견한 토큰을 출력하는 대신, 코드의 다른 부분에서 토큰의 유형을 나타내도록 정의한 값을 반환한다. lex에서도 몇 가지 문자는 특별한 의미가 있어 리터럴로 다루려면 이스케이프 해야 한다.

  ```lex
  0[0-7]* return (INTEGER);
  [+-]?[0-9]+ return (INTEGER);
  [+-]?(([0-9]*\.?[0-9]+)|([0-9]+\.?[0-9]*))([Ee][+-]?[0-9]+)? return (FLOAT);
  0x[0-9a-fA-F]+ return (INTEGER);
  [A-Za-z][A-Za-z0-9]* return (VARIABLE);
  \+ return (PLUS);
  - return (MINUS);
  \* return (TIMES);
  \/ return (DIVIDE);
  = return (EQUALS);
  ```

  이 목록에서는 lex가 어떻게 토큰의 실체값을 돌려주는 지에대해 관련한 부분을 생략했다. 토큰 유형이 수라는 사실을 알아냈다면 그 수의 값이 얼마인지를 알 필요가 있다. 마찬가지로 변수 토큰을 찾았다면 변수 이름이 무엇인지 알아야 한다.

  lex를 사용한 어휘 분석이 모든 언어에 대해 작동하지 않는다는 점에 유의하라. 곧 소개할 예정인 컴퓨터과학자 스티븐 C 존슨은 렉스를 사용하면 아주 복잡한 어휘 분석기도 쉽게 만들 수 있지만, 포트란처럼 어떤 이론적인 프레임워크에 어휘 체계가 들어맞지 않는 언어가 몇 가지 있고, 이런 언어의 어휘 분석기는 어쩔 수 없이 손으로 작성하는 수 밖에 없다고 설명했다.

  



### 단어에서 문장으로

지금까지는 문자 시퀀스를 단어로 분류하는 방법(어휘 분석)을 살펴봤다. 하지만 어를 처리하려면 어휘 분석만으로 충분하지 않다. 여러 단어를 모아서 어떤 문법에 맞는 문장으로 분석할 필요가 있다. 

토큰을 통해 사칙연산 계산기를 만든다고 가정할 때  1+2, a=5는 문법에 맞지만 1 ++ 2는 맞지 않는다. 여기서도 패턴 매칭이 필요하다는 사실을 알 수 있다. 하지만 이번에는 문자 시퀀스에 대한 패턴 매칭이 아니고 토큰으로 이뤄진 시퀀스에 대한 패턴 매칭이 필요하다.

스티븐 c 존슨은 1970년대 초반 yacc이라는 프로그램을 작성했다. 오늘날에도 여전히 사용되며 GNU에서 만든 오픈소스 버전인 bison도 있다. lex와 마찬가지로 yacc이나 bison은 상태 테이블을 만들고 이 테이블을 사용해 작동하는 코드를 생성해준다.

yacc이 만들어내는 프로그램은  스택을 사용하는 시프트 리듀스(shift-reduce) 파서(parser)다. 여시거 시프트는 토큰을 스택에 넣는다는 뜻이고, 리듀스는 스택의 맨 위부터 어떤 문법 패턴에 매치된 토큰들을 다른 어떤 것으로 대치한다는 뜻이다. 다음은 계산기의 BNF이다.

```
<operator> ::= PLUS | MINUS | TIMES | DIVIDE
<operand> ::= INTEGER | FLOAT | VARIABLE
<expression> ::= <operand> | <expression> PLUS <operand>
                           | <expression> MINUS <operand>
                           | <expression> TIMES <operand>
                           | <expression> DIVIDE <operand>
<assignment> ::= <variable> EQUALS <expression>
<statement> ::= <expression> | <assignment>
<statements> ::= "" | <statement> <statement>
<calculator> ::= <statements>
```

실제 동작을 보면 시프트-리듀스를 쉽게 이해할 수 있다. 파서가 `4+5-3` 이라는 입력을 만나면 다음과 같은 일이 벌어진다.

```
시작
시프트 : 4
시프트 : + 4
시프트 : 5 + 4
리듀스 : 9
시프트 : - 9
시프트 : 3 - 9
리듀스 : 6
```





### 누구나 프로그래밍 언어를 만들 수 있는 시대

과거에 언어를 만들기 어려웠지만 오즘 시대에는 다양한 언어들이 생겨났다. 심지어 프로그래밍 언어가 아닌 화학식 출력용 언어 chem이나 pic이라는 그림 생성 언어역시 생겨났다. 

또 언어의 역사를 잘 이해하지 못하고 과거에 저질렀던 실수를 반복하는 경우도 있다. 루비(Ruby)의 화이트스페이스 처리는 오래전 고쳐진 C언어 초기 버전의 실수를 되풀이 한 것이다. 

이 모든 역사의 결과 이제는 수많은 언어가 존재한다.





### 파스 트리

고수준 언어 컴파일에 대해 이야기 했지만 고수준 언어를 실행할 수 있는 방법은 컴파일만 있지 않고 인터프리트(interpret)할 수 있다. 인터프리트냐 컴파일이냐의 선택은 언어 설계 자체보다는 구현에 의해 이뤄진다.

컴파일 언어는 기계 코드를 만들어 낸다. 컴파일러는 소스 코드를 구체적인 기계에 맞는 기계어로 변환한다. 같은 프로그램에 대해 다른 컴파일러를 사용하면 다른 대상 기계를 위한 프로그램을 만들어낼 수 있다. 프로그램을 컴파일하고 나면 실행할 준비가 된 것이다.

인터프리터 언어는 실제 기계에 사용할 기계어를 만들어 내지는 않는다. 대신 인터프리터 언어는 가상 머신(virtual machine)에서 실행된다. 가상 머신은 소프트웨어로 작성된 기계다. 가상 머신도 자신만 실행할 수 있는 기계어를 제공하기도 하지만 이 기계어는 실제 하드웨어로 구현된 컴퓨터 명령어 집합은 아니다. 최근에는 '가상 머신'이라는 용어가 추상적인 계산 기계를 뜻할 수도 있음에 유의하라. 일부 인터프리터 언어는 인터프리터(interpreter)에 의해 직접 실행되기도 한다. 또 어떤 인터프리터 언어들은 나중에 해석될 수 있도록 중간어(interdediate language)로 컴파일 되기도 한다.

일반적으로 컴파일이 된 코드는 기계어 이기 때문에 빠르게 실행된다. 인터프리터에 의해 실행되는 코드는 마치 누군가가 영어로 된 책을 보면서 우리말로 즉시 번역해 읽어주는 것처럼 수명이 짧다. 하지만 인터프리터로 실행되는 코드는 하드웨어로 구현하기에 너무 힘든 기능을 제공할 수 있다. 컴퓨터는 아주 빠르기 때문에 종종 인터프리터로 인해 느려진 속도를 감수해도 좋을 때가 있다.

앞에서 시프트 리듀스처럼 계산기가 실행되도 충분하지만 이런 방식은 컴파일러나 인터프리터가 수행하는 중요한 단계를 건너뛴 것이다. 일반적으로 컴파일러나 인터프리터는 파스 트리(parse tree)를 구성한다. 파스 트리는 언어 문법으로부터 만들어낸 DAG(directed acyclic grap : 유향 비순환 그래프) 데이터 구조다. 이 트리를 6장에서 배운 노드 구조로부터 만들어낼 수 있다.

```
 node         union
 code       부동소수점 .f
leaf0 <---- 정수      .i
leaf1       노드 포인터 .n
leaf2       문자 배열   .s
```

각 노드에는 노드 유형을 표시하는 code와 잎(leaf)의 배열이 있다. 각 leaf의 해석은 code에 따라 달라진다. leaf는 여러 타입의 정보를 담을 수 있어야 하기 때문에 공용체다. 멤버 이름에는 C언어의 문법을 사용한다. 따라서 .i는 leaf가 정수인 경우를 표현한다.





### 인터프리터

파스 트리를 직접 실행하는 방법이 있고, 파스 트리를 파일에 저장했다가 나중에 읽어서 실행하는 방법도 있다. 자바나 파이썬 같은 언어가 이런 식으로 작동한다. 이런 언어에서 파일에 저장되는 내용은 기계어 명령어 들인데 하드웨어로 구현된 기계가 아니라 소프트웨엉로 구현된 기계의 명령어를 저장한다. 그리고 모든 대상 기계마다 저장된 파스 트리를 실행하는 프로그램이 있어야만 한다. 똑같은 인터프리터 소스 코드를 여러 대상 기계에 대해 컴파일해 사용하는 경우도 자주 있다.

```
인터프리터 구조
                   프론트 엔드
입력 프로그램 -> 어휘 분석 -> 문법 파싱 -> 파스 트리(중간 언어) -> 기계 1 백엔드
                                                    -> 기계 n 백엔드
```

프론트 엔드는 파스 트리를 만든다. 파스 트리는 어떤 중간 언어(intermediate language)로 표현된다. 백엔드(backend)는 이 언어를 실행할 대상 환경마다 하나씩 존재한다.





### 컴파일러

컴파일러도 인터프티러와 비슷해 보이나. 하지만 백엔드 실행 코드 대신 코드 생성기가 들어간다.

```
컴파일러 구조
                  프론트 엔드
입력 프로그램 -> 어휘 분석 -> 문법 파싱 -> 파스 트리(중간 언어) -> 기계 1 코드 생성기 -> 기계 1 어셈블리어 -> 기계 1 어셈블러 -> 기계 1 기계어
                                                    -> 기계 n 코드 생성기 -> 기계 n 어셈블리어 -> 기계 n 어셈블러 -> 기계 n 기계어
```

코드 생성기(code generator)는 특정 대상 기계에 대한 기계어 코드를 만들어낸다. C같은 일부 언어의 코드 생성기는 실제로 대상 기계의 어셈블리 언어 코드를 만들어 내고, 대상 기계의 어셈블러를 사용해 이 어셈블러를 사용해 이 어셈블리 언어 코드를 대상 기계의 기계어로 번역한다.

코드 생성기는 계산을 수행하는 어셈블리 코드를 만들어내도록 변환한다. 

코드 생성기는 보기에 별로 안 좋아 보이는 코드를 만들어낸다. 불필요한 load와 store가 많다. 최적화를 통해 코드를 더 개선할 수 있다.

코드를 어셈블러를 사용해 기계어로 번역하면 컴퓨터에서 실행할 수 있다. 컴파일된 기계어로 실행하면 코드가 더 작고 효율적이기 때문에 인터프리터로 실행할 때보다 훨씬 더 빠르게 실행된다.





### 최적화

대부분의 언어 도구에는 최적화기(operator)라는 추가 단계가 파스 트리와 코드 생성기 사이에 들어간다. 최적화기에는 파스 트리를 분석하고 이 겨로가를 활용해 더 나은 코드를 생성해내도록 파스 트리르 변환한다. 예를 들어 최적화기가 다음의 모든 피연산자가 상수라는 사실을 분석해낼 수 있다.

```
  plus    --최적화->  num
num times
   num  num
```

이런 경우 최적화기는 컴파일 시점에 식을 미리 계산해서 실행 시점에 따로 계산을 수행할 필요가 없게 만들 수 있다.

만든 계산기는 조건 분기를 할 방법이 없었기 때문에 앞에서 다뤘던 예제도 뻔한 예제였다. 최적화기에는 다양한 트릭이 스인다.

```c
for (i = 0; i < 10; i++) {
    x = a+b;
    result[i] = 4 * i + x*x;
}
```

다음은 최적화기가 재구성할 때 생길 법한 코드를 보여준다.

```c
x = a+b;
optimizer_created_temporary_variable = x*x;
for (i = 0; i < 10; i++) {
	result[i] = 4 * i + optimizer_created_temporary_variable;	
}
```

이 예제는 위의 코드와 똑같은 결과를 내지만 더 효율적이다. 최적화기는 a+b가 루프 불변 요소(loop invariant)라는 사실을 알아낸다. 루프 불변 요소는 루프를 반복해서 값이 변하지 않는다는 뜻이다. 최적화기는 이를 루프 밖으로 내보내서 10번 계산을 반복하지 않고 단 한 번 만 계산하게 만든다. 최적화기는 x*x가 루프 안에서 상수라는 사실도 알아내서 루프 밖으로 이를 끄집어낸다.

다음은 강도 절감(strength reduction)이라는 또 다른 최적화 트릭을 보여준다. 강도 절감은 비용이 많이 드는 연산을 비용이 더 적게 드는 연산으로 대신하는 방법이다. 여기서는 곱셈을 덧셈으로 바꿨다.

```c
x = a+b;
optimizer_created_temporary_variable = x*x;
optimizer_created_4_times_i = 0;
for (i = 0; i < 10; i++) {
    result[i] = optimizer_created_4_times_i + optimizer_created_temporary_variable;	
    optimizer_created_4_times_i = optimizer_created_4_times_i + 4;
}
```

감도 절감 시 상대 주소 지정의 장점을 활용해 result[i]를 더 효율적으로 계산하게 할 수도 있다. result[i]는 resut의 주소에 배열 원소 크기와 i를 곱한 값을 더한 위치를 가리킨다. optimizer_created_4_times_i와 비슷한 방식으로 연산 비용이 큰 곱셈 연산을 한 후 인덱싱을 하는 대신 result의 주소로부터 시작해서 루프를 반복할 때마다 배열 원소 크기만큼 주소를 증가시킬 수도 있다.





### 하드웨어를 다룰 때 주의하라

최적화기는 멋지지만 하드웨어를 조작하는 코드를 최적화하면 예기치 못한 문제가 발생할 수도 있다. 다음은 하드웨어 레지스터를 변수로 조작하는 코드를 보여준다.

```
// 비트가 0이도미녀 전등을 켜는 코드
void
lights_on()
{
	PROTB= 0x01;
	return ;
}
```

이 코드는 문제가 없다. 하지만 최적화기가 이 코드에 대해 어떤 조작을 가할까? 최적화기는 PORTB에 값을 쓰기만 하고 읽는 코드는 없다는 것을 알것이다. 그래서 코드를 제거한다고 결정한다. 다음은 전등을 켜고 전등이 켜진 상태인지 검사한다. 최적화기는 그냥 PORTB에 값을 저장하지 않고 0x01를 반환하도록 함수를 다시 작성할 수 있다.

```
unsigned int
lights_on()
{
	PORTB - 0x01;
	return (PORTB);
}
```

이 두 예제는 경우에 따라 최적화를 꺼야 할 수도 있음을 나타낸다. 전통적으로 SW를 일반적인 파일과 하드웨어에 따라 달라지는 파일로 나누고 일반적인 파일에 대해서만 최적화를 적용하는 식으로 이런 문제를 해결한다. 하지만 일부 언어는 최적화기에게 손대지 말아야할 부분을 알려주는 매커니즘을 제공한다. 예를 들어 C언어에서 volatile 키워드는 변수에 대한 접근을 최적화하지 말라고 지정한다.





### 정리

지금까지는 이 책에서 컴퓨터가 어떻게 작동하고 어떻게 프로그램을 실행하는지 배웠다. 프로그램을 기계에서 실행하기 위해 어떻게 변환하는지 설명하고 프로그램을 컴파일 하거나 인터프리트하는 방법을 배웠다.
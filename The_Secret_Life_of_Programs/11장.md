## 성능 향상을 위한 알고리즘 기법

> 계산을 간소화하는 프로그래밍 트릭



지금까지 계산을 효율적으로 하는 방법을 살펴보면서 많은 시간을 보냈다. 특히 메모리 사용과 관련한 내용을 많이 살펴봤다. 하지만 계산을 효율적으로 하는 것보다는 계산을 하지 않는 것이 더 유리하다. 두 가지 방법은 지름길(shortcut)과 근갓값 계산(approximating)이다.



컴퓨터는 실수를 표현하는 방식에서 실수가 있는 것처럼 실제로는 아주 정확하고 정밀하지는 않다. 우리는 우리가 원하는 만큼 정확하게 코드를 작성할 수 있다. 유닉스의 `bc`라는 유틸리티는 임이의 정밀도를 제공하는 계산기이기 때문에 아주 정확한 계산이 필요한 경우에 딱 알맞는 도구다. 하지만 컴퓨터 하드웨어가 무제한 정밀도를 허용하지는 않기 때문에 그리 효율적인 접근 방법은 안된다. 컴퓨터의 자원을 효율적으로 사용한다는 말은 필요보다 더 많은 계산을 하지 않는다는 것을 말한다. 





### 표 찾기

직접 계산하는 것보다 표에서 무언가를 찾는게 더 빠를 때가 종종 있다. 표 찾기는 어떤 계산을 많이 하는 경우 그 결과를 미리 계산해서 반복 사용하는 편이 합리적이다.

* 변환

  온도를 계산하는 공식은 다음과 같다.
  $$
  t = 1/ A + B + \log_e v + (C * \log_e v)^2
  $$
   공식을 보면 자연 로그 공식이 많아 부동 소수점 계산이 많이 필요하다. 따라서 전압과 온도의 관계표를 만들어서 들어온 전압을 표에 있는 값으로 변환해 내보내면 된다.

* 텍스처 매핑

  비디오 게임이나 영화에서 진짜처럼 보이는 이미지를 만들기 위해 사용하는 텍스처 매핑(texture mapping)에서 표 찾기 기법이 중요한 역할을 한다. 텍스처 매핑은 벽 등 3차원 물체의 표명을 표현하기 위해 직접 표면의 질감을 계산해 생성하는 것보다 이미지를 벽을 표현하는 물체(3차원 물체)의 표면에 그리는 편이 훨씬 더 적은 계산이 필요하다는 데 필요하다는 데 착안한 것이다. 텍스처 매핑은 잘 작동하고 효과도 좋지만 텍스처 매핑으로 인해 생기는 문제도 있다.

  비디오 게임에서 벽돌 모양은 벽에서 플레이어가 얼마나 멀리 떨어져 있느냐에 따라 바뀔 필요가 있다. 가까울 수록 벽돌의 모양이 더 선명하게 보여야 하며 멀어질 수록 벽돌이 흐릿하게 보여야 한다.

  거리에 따라 텍스쳐를 조정하는 일은 뷰포인트(viewpoint)가 텍스처에서 멀어지면 인접한 픽셀을 서로 합쳐서 평균을 내야 한다. 벽 이미지가 바뀌지 않으려면 이를 빠르게 수행해야 한다.

  뉴욕 공과대학 그래픽 언어 실험실의 랜스 윌리엄스는 MIP 매핑이라는 똑똑한 접근 방법을 고안했다. (MIP는 multum in parvo의 약자로 많은 것을 작은 공간에 넣음). 랜스는 '피라미드형 파라미터 사전 필터링(Pyramidal Parametrics)'이라는 논문을 1983년 학회지에 발표했고 랜스가 고안한 방법은 오늘날에도 사용되며, 소프트웨어 뿐만 아니라 하드웨어에서도 쓰이고 있다.

  픽셀은 세 가지 8비트 값으로 이뤄진다. 각각을 RGB를 표현한다. 윌리엄스는 32비트 시스템에서 1/4을 낭비한다는 사실에 주목했다.

  윌리엄스는 이 미사용 공간을 그냥 낭비하게 둘 수 없었다. 그래서 투명도 추가와는 다르게 이 공간을 활용하는 방법을 생각해냈다. 이 부분이 전체 공간의 1/4이기 때문에 여기에 이미지의 1/4 크기 복사본을 넣는다. 이런 식으로 하면 그려면 1/16의 공간이 비게 되는데 여기에 1/4의 1/4를 다시 넣는다. 이런 방식의 이미지를 MIP 맵이라고 한다.

  벽돌 텍스처로부터 MIP 맵을 만드면 클로즈업 된 이미지가 더 자세하다. 이 점은 뷰 포인터에서 먼 거리에서 가까운 거리로 올 수록 이미지가 더 자세하게 보여줌으로써 더 이상 평균값을 취할 필요가 없게 된다. 자주 사용할 정보를 미리 계산해두는 것이 위에서 변환가 비슷하다.

* 문자 종류 판별

  표 찾기 방식은 프로그래밍 언어의 라이브러리 추가에도 큰 영향을 끼쳤다. 어떤 글자가 숫자, 문자 등 어떤 분류에 속하는지 판별하는 문제인 문자 종류 판별(character classification)이 어휘 분석에서 중요한 부분이라는 사실을 설명했다. 아스키 코드 표를 보면 다음과 같은 문자 종류 판별 코드를 작성할 수 있다.

  ```c
  int isdigit(int c)
  {
      return (c >= '0' && c <= '9');
  }
  
  int ishexdigit(int c)
  {
      return (c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f');
  }
  
  int isalpha(int c)
  {
      return (c >='A' && c <= 'Z' || c >= 'a' && c <= 'z');
  }
  
  int isupper(int c)
  {
      return (c >= 'A' && c <= 'Z');
  }
  ```

  벨 연구소의 누군가 유용한 공통 함수를 라이브러리에 넣자고 제안했다. 데니스 리치는 사람들이 쉽게 그런 코드를 작성할 수 있다고 주장했다. 하지만 컴퓨터 센터에 있는 닐스 피터 넬슨은 if문 대신 표를 써서 이런 루틴(routine : 함수나 프로시저를 부르는 다른 말)을 구현했다. 표는 문잣값을 인덱스로 사용하고, 표의 각 원소의 비트는 대문자, 소문자, 숫자 등 문자의 여러가지 특성을 표현한다.

  문자 종류 판별은 표를 검색해 비트를 살펴보는 과정으로 이뤄진다.

  ```c
  unsigned char table[128] = [...];
  
  #define isdigit(c) (table[(c) & 0x7f] & DIGIT)
  #define ishexdigit(c) (table[(c) & 0x7f] & HEXADECIMAL)
  #define isalpha(c) (table[(c) & 0x7f] & (UPPER | LOWER))
  #define isupper(c) (table[(c) & 0x7f] & UPPER)
  ```

  코드를 보면 함수보다 표를 사용하는 것이 더 간단함을 알 수 있다. 그리고 이 모든 코드는 근본적으로 같게 작동하고 유일한 차이는 표의 내용과 비트 연산을 할 때 사용하는 상숫값뿐이라는 장점이 있다. 이 접근 방식은 모둔 구현 코드보다 20배 빨랐기 때문에 리치는 이 코드 채택해 라이브러리에 추가했고 이 코드를 바탕으로 다른 라이브러리 코드가 구현되게 했다. 또한 코드가 적을 때 함수 대신 매크로를 사용하면 전처리기가 코드를 `table[('a' & 0x7f)] & UPPER`로 바꿔주면서 함수 호출과 반환에 따른 부가 비용을 줄일수 있다.





### 정수를 사용한 계산 방법

일부 연산이 다른 연산보다 속도나 전력 소모에서 비용이 더 적게 든다는 사실을 분명히 알 수 있다. 정수 덧셈이나 뺄셈은 비용이 싸다. 시프트 연산으로 대신할 수 있는 2의 거듭 제곱으로 나누거나 곱하는 경우를 제외하면 곱셈이나 나눗셈은 비용이 더 많이 든다. 부동소수점 연산은 더더욱 비싸다고 여겨진다. 삼각함수나 로그 함수 계산등의 복잡한 부동소수점 계산은 훨씬 더 비싸다. 더 비싼 연산을 피할 수 있는 방법을 찾아내면 바람직할 것이다.

```html
<style>
    canvas {
        border : 5px solid black;
    }
</style>
<script>
	$(function() {
        var canvas = $('canvas')[0].getContext('2d');
        // 캔버스의 높이와 너비를 얻는다. js에서 문자열을 숫자 대신 사용하면 예기치 못한 결과를 얻을 수 있다.
        // 이를 방지하기 위해 얻은 값을 강제로 Number로 변환한다.
       	var height = Number($('canvas').attr('height'))
        var width = Number($('canvas').attr('width'))
        
        canvas.translate(0, height)
        canvas.scale(1, -1);
    })
</script>
<body>
    <canvas width="500" height="500"></canvas>
</body>
```

캔버스(canvas)는 자유롭게 그림을 그릴 수 있는 엘리멘트로 모눈종이처럼 생각하면 된다.

캔버스 '모눈종이'는 기본적으로 표준적인 직교 좌표계(Cartesian coordinate system)를 사용하지 않기 때문에 여러분이 그래프를 그릴 때 쓰던 방식과는 다르다. 이렇게 된 이유는 텔레비전에 래스터로 화면을 그리던 방향의 영향을 받았기 때문이다. 래스터는 왼쪽 위에서 시작해 x축으로는 왼쪽에서 오른쪽 y축에서는 위에서 아래 방향으로 이동한다. 그래서 x 좌표는 일반적인 x좌표와 같고 y 좌표는 위에서 아래로 이동하므로 위에서 아래로 갈수록 점점 커진다. 텔레비전 모니터를 컴퓨터 그래픽 용 모니터로 목적을 바꿔 사용하기 시작하면서 이런 좌표계가 유지 됐다.

현대적인 컴퓨터 그래픽 시스템은 임의로 좌표계를 변환하도록 지원하고 이런 변환을 그래픽 하드웨어가 지원하는 경우도 많다. 이런 변환을 그래픽 하드웨어가 지원하는 경우도 많다. 모든 `(x, y)` 좌표에 대해 다음 식과 같은 변환을 통해 지정한 좌표를 `(x', x')`으로 변환해준다.
$$
x' = Ax + By + C \\

y' = Dx + Ey +F
$$
C와 F는 평행이동(translation)에 쓰인다. 이 말은 물체의 각 점을 축 방향으로 나란히 움직인다는 뜻이다. A와 E는 크기 변환(scaling)에 기여한다. B와 D는 회전(rotation)에 기여한다. 이들을 행렬로 표현하는 경우가 많다.

.. 이하는 디스플레이 관련으로 나중에 한꺼번에 업데이트함.
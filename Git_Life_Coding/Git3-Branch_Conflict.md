# git3



### intro

브랜치는 다른 작업이 추가된 복제본이 필요한 경우가 있다. 어떤 제품을 만들 경우 여러 개의 다른 기능을 가진 제품을 만들 때가 있다. 이럴 경우 브랜치를 만들게 되면 같은 뿌리에서 시작하여 새로운 기능을 가진 제품들을 만들 수 있다.

브랜치를 만들면 충돌을 피할 수가 없는데, 같은 파일에서 같은 부분이 수정되었다면 머지가 멈추게 되고 충돌이 났음을 알린다.





### 브랜치의 기본사용법

브랜치를 만들고 활용하고 열람하고 사용하는 것을 알아볼 것이다. 

로그에서 먼저 그 동안 만들게 될 모든 브랜치를 보려면 `--all` 옵션이 필요하고 `--graph` 옵션은 시각적으로 표현해준다. 그래프가 장황하지 않도록 `--oneline`이라는 옵션을 사용한다.



먼저 레포지토리가 가지고 있는 브랜치의 목록을 보려면 다음 명령어가 필요하다.

```powershell
git branch
```

이제 브랜치를 생성하는 명령어는 다음과 같다.

```powershell
git branch 브랜치이름
```

이제 브랜치를 이동하는 명령어는 다음과 같다.

```powershell
git checkout 브랜치이름
```

이때 만들어진 브랜치는 현재 버전에서 버전을 찍으며 나아간다. 브랜치에서 작업하는 내용은 브랜치에 귀속 된다. 만약 작업을 완료한 뒤 main혹은 master로 돌아가게 된다면 브랜치에서 작업한 내용은 사라지고 마스터가 가진 버전을 보게 된다. 





### 브랜치의 기본사용법2

브랜치를 전환할 때는 checkout 브랜치의 마지막 커밋 상태로 우리의 상태가 바뀐다.

어떤 브랜치에 있을 때 그 브랜치에서 작업을 한 뒤 커밋을 찍는다. 브랜치의 버전의 부모는 master이였을 테지만 브랜치마다 다른 버전을 가질 수 있게 만들 수 있다.

우리는 브랜치를 통해 브랜치에서 작업했던 내용으로 돌아갈 수도 있고 필요한 버전마다 저장소를 만들 필요 없이 하나의 저장소 안에서 브랜치를 통해 각자 다른 작업을 가지고 있는 프로젝트를 가질 수 있다.





### 병합(merge)

브랜치를 만들고 브랜치에 작업을 하면 그 작업 내용은 브랜치에 남게 된다. 브랜치에 남은 내용들을 머지하고 싶어질 것이다. 메인 브랜치에서 작업한 내용과 브랜치에서 동작하는 내용이 합쳐질 것이다. 

합치려고 하는 공통 조상을 base라고 한다. 그리고 base를 바탕으로 새로운 버전을 만드는데 머지된 커밋을 merge commit이라고 한다. 이 과정을 수동으로 하려면 구석구석에 있는 코드를 합쳐야 할 것이다. 하지만 git은 대부분 자동화 해준다.





### 병합 : 서로 다른 파일 병합

 가장 최근의 커밋 내용을 수정하는 명령어

```powershell
git commit --amend
```

에디터가 뜨면서 커밋 내용을 수정할 수 있다.



base를 가지고 있는 각각의 브랜치에서 서로 다른 파일을 만들어라. 그렇게 하면 브랜치는 서로 다른 버전을 갖게 될 것이다. 1브랜치에 2브랜치 내용을 병합 하고자 할 때 

1. 먼저 병합될 브랜치에 있는 것이 아니라 내가 남기고 싶은 브랜치에 있어야 한다. 

2. 현재 브랜치에서 가져올 브랜치를 명령으로 지정한다.

   ```powershell
   git merge 가져올브랜치이름
   ```

3. 머지되면서 커밋을 남길 수 있는데 이 커밋 메시지는 머지되면서 남기는 커밋이다.

이것이 머지를 하는 방법이다.

reset을 할 때 머지되기 전 상태로도 돌릴 수 있다.





### 병합 : 같은 파일 다른부분 병합

파일명이 다른 것 끼리 다른 파일끼리 병합되는 것을 보았다. 

같은 파일안에서 다른 부분이 수정되어 있는 것을 머지할 수 도 있다.

이때 다른 부분은 말 그대로 한 파일 안에서 다른 부분을 수정해야 한다. 

그런 뒤 병합하려는 브랜치로 가서

```powershell
git merge 병합될브랜치
```

명령어를 치면 commit 메시지를 입력하고 병합이 될 것이다.





### 병합 : 같은파일, 같은부분 병합

같은 파일안에서 같은부분을 병합하려 했을 경우 git은 병합하지 못한다. 이때 충돌이 난다고 (conflict 가 발생했다고)한다.

컨플릭트가 발생한다면 conflict 메시지가 발생한다. 이 때 명령 충돌 난 곳을 해결하고 다시 병합을 시도해 달라고 뜬다.

이때 컨플릭트가 난 파일을 들어가 보면 

```
>>> HEAD
master 
========
master2
>>>> master2
```

같은 모습인 것을 볼 수 있다. >>> 는 브랜치 이름을 알려주고 ====을 통해 내용을 위 아래로 구분하여 무엇을 선택해야 할지 정해야 한다.

둘다 남기고 싶다면 >>>줄과 ===줄을 모두 지우고

```
master, master2
```

내용을 남기고 저장한다.

그리고 다시 파일을 `add`한다. 그리고 커밋을 찍어준다. 그런 뒤 파일은 자동으로 머지된다.



충돌이 일어났을 경우 충돌을 해결해주고 다시 저장하면 된다.





### 충돌 : 3 way merge

어떤 파일에서 파일을 수정할 때를 예시로 병합의 과정을 살펴보자.

두 브랜치의 내용은 다음과 같다.

```
here there merged
  A    A     A
  H    B     ?
  C    T     ?
  H    T     ?
```

둘을 합칠 때 here, there 둘 다 상태가 다를 경우 충돌이 발생한다.

즉 위의 경우의 수에서 3가지가 충돌이 발생한다. 두 개의 브랜치를 비교해서 병합하는 과정을 2 way merge라고 하고 3 way merge가 등장한다.

here와 there의 공통된 뿌리 base가 탄생하게 된다.

```
base  here there merged
  A     A    A     A
  B     H    B     H
  C     C    T     T
  D     H    T     ?
```

두 브랜치 중 base가 가진 값을 기준으로 base에서 값이 달라진 부분을 채택한다. 여전히 두 브랜치 모두 수정되었다면 base는 무엇을 채택해야 할 지 모르기 때문에 여전히 충돌이 유지된다.





### 충돌 : 외부도구를 이용한 병합

mergetool은 git의 merge 도구이다. 대표적인 예시로 p4merge라는 프로그램이 존재한다.





### 수업을 마치며

git workflow : 여러 파일들이 있을 것이고 git flow라는 것이 있다. git의 브랜치 전략이다. 

Cherry-pick : 병합과 관련된 기능으로 브랜치의 일부 내용만을 다른 브랜치로 병합할 수 있다. 부분 병합을 하는 방법을 살펴보면 좋을 것이다.

rebase : merge와 목표는 같다. rebase를 사용하면 타임라인을 쉽게 짤 수 있다. other 브랜치를 master 브랜치와 병합하여 새로운 베이스를 만드는 것이다.





### HEAD BRANCH COMMIT & CHECKOUT

head, branch, commit

우리가 저장소를 만들면 head라는 파일이 만들어진다. 그 안에는 기본적으로 생성되는 브랜치가 존재한다. git파일을 만들게 되면 default branch가 존재한다.

commit을 만들게 되면 default 브랜치는 제일먼저 commit을 가리키게 된다. Commit을 한 번 더하면 default 브랜치는 다음 커밋을 가리키게 된다.

즉 현재 버전이라는 것은 Head가 가리키는 브랜치가 가리키는 버전을 말한다. 

새로 브랜치를 만들면 현재 버전에서 시작한다. 

head가 다른 브랜치를 가리키고 커밋을 찍으면 브랜치마다 다른 버전을 갖게 된다. 

우리가 하는 명령어 checkout은 head가 가리키는 브랜치를 바꾸는 것이다. `git checkout 커밋아이디`를 하게 되면 head는 커밋의 저장소를 직접 가리킨다. head가 브랜치를 가리키지 않고 커밋을 가리키는 상태를 브랜치로부터 떨어져 있다 하여 detached 상태에 있다고 얘기한다.

checkout은 head를 제어하는 것이다.





### checkout vs reset

checkout과 reset의 차이점은 무엇일까? 

checkout은 head를 제어하고 reset은 head가 branch를 가리키는 동안에는 branch를 제어한다.

```
git checkout master
```

위의 명령어는 head는 master 브랜치를 가리킨다. 결과적으로 master 브랜치에 속해 있게 되고 현재 working copy는 master 브랜치의 버전을 가지게 된다. 

```
git reset --hard master
```

reset 마스터는 다른 브랜치가 master가 가리키는 버전으로 바꾸는 것이다. 그러면 브랜치 입장에서는 다른 버전을 가리키게 되면서 원래 버전은 사라지게 된다. 커밋 이후에 등장하는 링크는 끊기게 된다.

